<!DOCTYPE html><html><head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title>06-Lambda-cube</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="slider.css">
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
  <div style="width: 640px;height: 400px;">
  <input id="slider-max" type="checkbox" checked="">
   <article class="slider slider-indicator">
   <a id="slider-default"></a>
   <label for="slider-max" title="Maximize"></label>


<section id="математические-модели-вычислений" class="slide level1">
<h1>Математические модели вычислений</h1>
<h2 id="λ-исчисление-с-простыми-типами">λ-исчисление с простыми типами</h2>
<h2 id="расширения-типизированного-λ-исчисления">Расширения типизированного λ-исчисления</h2>
<h2 id="полиморфное-λ-исчисление">Полиморфное λ-исчисление</h2>
<h2 id="λ-исчисление-с-конструкторами-типов">λ-исчисление с конструкторами типов</h2>
<p><a href="mailto:maxim.krivchikov@gmail.com" class="email">maxim.krivchikov@gmail.com</a></p>
<a href="https://maxxk.github.io/formal-models/" class="uri">https://maxxk.github.io/formal-models/</a>
<style>
.inference table {
    display: inline-block;
    padding: 1em;
}

.inference table th {
    font-weight: normal;
    border-bottom: 1px solid black;
}
</style>
</section><div><a class="slider-prev"></a><a class="slider-next" href="#λ-исчисление-с-простыми-типами-1"></a></div>
<section id="λ-исчисление-с-простыми-типами-1" class="slide level1 inference">
<h1 class="inference">λ-исчисление с простыми типами</h1>
<p><span class="math display"><em>τ</em>≡ <em>b</em> | <em>τ</em><sub>1</sub> → <em>τ</em><sub>2</sub>,   <em>b</em> ∈ <em>B</em>.</span></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><span class="math inline">   </span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Γ, x : α ⊦ x : α</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><span class="math inline"><em>c</em><sub><em>α</em></sub></span> — постоянная типа α</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Γ ⊦ c: α</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Γ, x : σ ⊦ e : τ</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Γ ⊦ (λ <span class="math inline"><em>x</em><sub><em>σ</em></sub></span> . e) : σ → τ</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Γ ⊦ x : σ → τ <span class="math inline">   </span> Γ ⊦ y : σ</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Γ ⊦ x · y : τ</td>
</tr>
</tbody>
</table>
</section><div><a class="slider-prev" href="#математические-модели-вычислений"></a><a class="slider-next" href="#исчисление-высказываний--соответствие-карри-говарда"></a></div>
<section id="исчисление-высказываний--соответствие-карри-говарда" class="slide level1 inference">
<h1 class="inference">Исчисление высказываний / соответствие Карри-Говарда</h1>
<p>Типы можно рассматривать как импликативные суждения (α → β — импликация). Доказательства — термы, имеющие этот тип.</p>
<p>Импликативный фрагмент схем аксиом исчисления высказываний:</p>
<ol type="a">
<li class="fragment"><em>A → (B → A)</em> — абстракция</li>
</ol>
<p><span class="math inline"><em>a</em><sub>1</sub> ≡ <em>λ</em><em>x</em><sub><em>A</em></sub>.<em>λ</em><em>y</em><sub><em>B</em></sub>.<em>x</em> : <em>A</em> → (<em>B</em> → <em>A</em>)   </span> Комбинатор <strong>K</strong> (<strong>K</strong> x y = x)</p>
<p>Действие правила <em>modus ponens:</em></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Γ ⊦ z : A <span class="math inline">   </span> Γ ⊦ a₁ : A → (B → A)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Γ ⊦ a₁ · z : B → A</td>
</tr>
</tbody>
</table>
<p>Редукция («упрощение доказательства»): <span class="math inline"><em>a</em><sub>1</sub> · <em>z</em> ≡ (<em>λ</em><em>x</em><sub><em>A</em></sub>.<em>λ</em><em>y</em><sub><em>B</em></sub>.<em>x</em>) · <em>z</em> ⟶ <em>λ</em><em>y</em><sub><em>B</em></sub>.<em>z</em></span></p>
</section><div><a class="slider-prev" href="#λ-исчисление-с-простыми-типами-1"></a><a class="slider-next" href="#исчисление-высказываний--соответствие-карри-говарда-1"></a></div>
<section id="исчисление-высказываний--соответствие-карри-говарда-1" class="slide level1">
<h1>Исчисление высказываний / соответствие Карри-Говарда</h1>
<ol start="2" type="a">
<li class="fragment"><em>(A → (B → C)) → ((A → B) → (A → C))</em> — «композиция»</li>
</ol>
<p>a₂ ≡ λ g<sub>A→(B→C)</sub> . λ f<sub>A→B</sub> . λ x<sub>A</sub> . g · x · (f · x)</p>
<p>a₂ : (A → (B → C)) → ((A → B) → (A → C))</p>
<p>Комбинатор <strong>S</strong> (<strong>S</strong> g f x = g x (f x))</p>
<p>Вывод типа a<sub>2</sub> : (A → (B → C)) → ((A → B) → (A → C))</p>
<table style="width:99%;">
<colgroup>
<col style="width: 19%">
<col style="width: 80%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Правило</th>
<th style="text-align: center;">Формула</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">T-Abs для <span class="math inline"><em>g</em></span></td>
<td style="text-align: center;">Γ, <strong>g : A → (B → C)</strong> ⊦ λ f<sub>A→B</sub> . λ x<sub>A</sub> . g · x · (f · x) : (A → B) → (A → C)</td>
</tr>
<tr class="even">
<td style="text-align: center;">T-Abs для <span class="math inline"><em>f</em></span></td>
<td style="text-align: center;">Γ, g : A → (B → C), <strong>f : A → B</strong> ⊦ λ x<sub>A</sub> . g · x · (f · x) : A → C</td>
</tr>
<tr class="odd">
<td style="text-align: center;">T-Abs для <span class="math inline"><em>x</em></span></td>
<td style="text-align: center;">Γ, g : A → (B → C), f : A → B, <strong>x : A</strong> ⊦ g · x · (f · x) : A → C</td>
</tr>
<tr class="even">
<td style="text-align: center;">T-App для <span class="math inline"><em>g</em> · <em>x</em></span></td>
<td style="text-align: center;">Γ, g : A → (B → C) ⊦ g : A → (B → C) Γ, x : A ⊦ x : A g · x : B → C</td>
</tr>
<tr class="odd">
<td style="text-align: center;">T-App для <span class="math inline"><em>f</em> · <em>x</em></span></td>
<td style="text-align: center;">(аналогично)</td>
</tr>
<tr class="even">
<td style="text-align: center;">T-App для <span class="math inline">(<em>g</em> · <em>x</em>) · (<em>f</em> · <em>x</em>)</span></td>
<td style="text-align: center;">(аналогично)</td>
</tr>
</tbody>
</table>
</section><div><a class="slider-prev" href="#исчисление-высказываний--соответствие-карри-говарда"></a><a class="slider-next" href="#типы-данных-для-λ-исчисления-с-простыми-типами"></a></div>
<section id="типы-данных-для-λ-исчисления-с-простыми-типами" class="slide level1 inference">
<h1 class="inference">Типы данных для λ-исчисления с простыми типами</h1>
<h2 id="пустой-тип">Пустой тип</h2>
<p>τ = … ⟂ …</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Γ ⊦ x : ⊥</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Γ ⊦ <span class="math inline"><em>e</em><em>x</em><em>f</em><em>a</em><em>l</em><em>s</em><em>o</em><sub><em>α</em></sub></span>(x) : α</td>
</tr>
</tbody>
</table>
<p>Отрицание:</p>
<p>не α ≡ α → ⟂</p>
<h2 id="тип-из-одного-элемента">Тип из одного элемента</h2>
<p>τ = … T …</p>
<p>Γ ⊦ () : T</p>
</section><div><a class="slider-prev" href="#исчисление-высказываний--соответствие-карри-говарда-1"></a><a class="slider-next" href="#произведение-конъюнкция-кортеж"></a></div>
<section id="произведение-конъюнкция-кортеж" class="slide level1 inference">
<h1 class="inference">Произведение (конъюнкция; кортеж)</h1>
<p>τ = … α × β …</p>
<p>Введение:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Γ ⊦ x : α <span class="math inline">   </span> Γ ⊦ y : β</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Γ ⊦ (x, y) : α × β</td>
</tr>
</tbody>
</table>
<p>Удаление:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Γ ⊦ p : α × β</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Γ ⊦ fst p : α</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Γ ⊦ p : α × β</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Γ ⊦ snd p : β</td>
</tr>
</tbody>
</table>
<p>Редукция: fst (x, y) ⟶ x <span class="math inline">   </span> snd (x, y) ⟶ y</p>
<p>Операция каррирования: (α×β → γ) → α → β → γ</p>
<p>Можно сравнить с аксиомами исчисления высказываний для конъюнкции: <a href="https://maxxk.github.io/formal-models/presentations/04-Logics.html#%D0%B8%D1%81%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2%D1%8B%D1%81%D0%BA%D0%B0%D0%B7%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B9" class="uri">https://maxxk.github.io/formal-models/presentations/04-Logics.html#%D0%B8%D1%81%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2%D1%8B%D1%81%D0%BA%D0%B0%D0%B7%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B9</a></p>
</section><div><a class="slider-prev" href="#типы-данных-для-λ-исчисления-с-простыми-типами"></a><a class="slider-next" href="#сумма-дизъюнкция-алгебраические-типы-данных"></a></div>
<section id="сумма-дизъюнкция-алгебраические-типы-данных" class="slide level1 inference">
<h1 class="inference">Сумма (дизъюнкция; алгебраические типы данных)</h1>
<p>τ = … α + β …</p>
<p>Введение:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Γ ⊦ x : α</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Γ ⊦ <span class="math inline"><em>i</em><em>n</em><em>l</em><sub><em>β</em></sub></span> x : α + b</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Γ ⊦ y : β</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Γ ⊦ <span class="math inline"><em>i</em><em>n</em><em>r</em><sub><em>α</em></sub></span> y : α + b</td>
</tr>
</tbody>
</table>
<p>Удаление:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">Γ ⊦ x : α + β <span class="math inline">   </span> Γ ⊦ s : α → γ <span class="math inline">   </span> Γ ⊦ t : β → γ</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Γ ⊦ <span class="math inline"><em>s</em><em>w</em><em>i</em><em>t</em><em>c</em><em>h</em><sub><em>γ</em></sub></span>(x, s, t) : γ</td>
</tr>
</tbody>
</table>
<p>Редукция:</p>
<p><span class="math inline"><em>s</em><em>w</em><em>i</em><em>t</em><em>c</em><em>h</em><sub><em>γ</em></sub></span>(<span class="math inline"><em>i</em><em>n</em><em>l</em><sub><em>β</em></sub></span> a, s, t) ⟶ s · a <span class="math inline">   </span> <span class="math inline"><em>s</em><em>w</em><em>i</em><em>t</em><em>c</em><em>h</em><sub><em>γ</em></sub></span>(<span class="math inline"><em>i</em><em>n</em><em>r</em><sub><em>α</em></sub></span> b, s, t ) ⟶ t · b</p>
</section><div><a class="slider-prev" href="#произведение-конъюнкция-кортеж"></a><a class="slider-next" href="#типы-для-простого-императивного-яп"></a></div>
<section id="типы-для-простого-императивного-яп" class="slide level1">
<h1>Типы для простого императивного ЯП</h1>
<p>Просто типизированное λ-исчисление можно использовать как основу для системы типов простого языка программирования (скорее Pascal-подобного, чем C-подобного).</p>
<div style="float: left; width: 55%; font-size: 0.9em;">
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">extern</span> <span class="dt">int</span> callback(<span class="dt">int</span>);</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="kw">extern</span> <span class="dt">void</span> set_callback(<span class="dt">int</span> (*cb)(<span class="dt">int</span>));</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="dt">int</span> main(<span class="dt">int</span> argc, StringArray argv) {</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>  <span class="dt">double</span> x;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>  x = callback(<span class="dv">0</span>);</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>  set_callback(callback);</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>  <span class="cf">return</span> callback(argc);</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a>}</span></code></pre></div>
<p>Программу на простом императивном языке можно транслировать в просто типизированное λ-исчисление и получить средство проверки типов. Наборы аргументов — произведения. Если аргументов более двух, как правило, считаем произведение правоассоциативным:</p>
<p>int × StringArray × double × int = int × (StringArray × (double × int)). Доступ к аргументам тогда осуществляется с использованием последовательности термов snd.</p>
</div>
<div style="float: right; width: 31%">
<p>λ callback<sub>int→int</sub>. λ set_callback<sub>(int→int)→T</sub>. λ main_args<sub>int×StringArray→int</sub>. λ get_x<sub>double</sub>. λ set_x<sub>double→T</sub>. (set_x · (callback · 0), set_callback · callback, callback · fst main_args ) : T × T × int</p>
</div>
</section><div><a class="slider-prev" href="#сумма-дизъюнкция-алгебраические-типы-данных"></a><a class="slider-next" href="#задачи-анализа-термов-λ-исчисления"></a></div>
<section id="задачи-анализа-термов-λ-исчисления" class="slide level1">
<h1>Задачи анализа термов λ-исчисления</h1>
<ol type="1">
<li class="fragment"><p><strong>Задача проверки типов</strong> (Type Checking). Даны терм T и тип σ. Определить, имеет ли T тип σ (фактически — построить вывод в формальной системе).</p></li>
<li class="fragment"><p><strong>Задача вывода типа</strong> (Type Inference). Дан терм T. Найти тип терма, если терм корректно типизирован, или указать на нарушение условий типизации.</p></li>
<li class="fragment"><p><strong>Задача поиска доказательства</strong> (обитаемости типа, Type Inhabitation). Дан тип σ. Определить, существует ли терм, имеющий такой тип и, если он существует, предъявить такой терм.</p></li>
<li class="fragment"><p><strong>Задача эквивалентности типов</strong>. Даны типы σ и τ. Определить, эквивалентны ли они.</p></li>
</ol>
<p>Для λ-исчисления с простыми типами все эти задачи разрешимы, в частности, четвёртая — тривиальна.</p>
<p>(слайд по мотивам презентации по <a href="https://compsciclub.ru/attachments/classes/slides_y2A06WZM/systemsoftypedlambdacalculi_lecture_130311.pdf">ссылке</a>; сам <a href="http://compsciclub.ru/courses/systemsoftypedlambdacalculi/2011-spring/">курс Д.Н. Москвина</a> можно рекомендовать как дополнительный источник по предыдущей, этой и, частично, следующей лекциям)</p>
</section><div><a class="slider-prev" href="#типы-для-простого-императивного-яп"></a><a class="slider-next" href="#двусторонний-алгоритм-проверки-типов"></a></div>
<section id="двусторонний-алгоритм-проверки-типов" class="slide level1 inference">
<h1 class="inference">Двусторонний алгоритм проверки типов</h1>
<div style="float:left; width: 40%; font-size: 0.9em;">
<p>Введём дополнительный терм «аннотация типов», подсказку для алгоритма проверки типов:</p>
<p>Определим две функции:</p>
<p>Вывод неизвестного типа</p>
<p>infer : Контекст → Терм → Тип?</p>
<p>infer(Γ, x) = τ ⇒ Γ ⊦ x : τ</p>
<pre><code>infer(… ∪ x : τ ∪ …, x) ≡ τ

infer(Γ, c) = α, где c — константа типа α

infer(Γ, x · y) = 
  if infer(Γ, x) = α → β 
    and check(y, α) 
  then β 
  else fail

infer(Γ, (x : τ)) = 
  if check(x, τ) 
  then τ 
  else fail

infer(Γ, λ x_α . y) = α → infer(Γ ∪ x : α, y)</code></pre>
</div>
<div style="float:right; width: 40%; font-size: 0.9em;">
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Γ ⊦ x : τ</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Γ ⊦ (x : τ) : τ</td>
</tr>
</tbody>
</table>
<p>Проверка известного типа</p>
<p>check : Контекст → Терм → Тип → <strong>2</strong></p>
<p>check(Γ, x, τ) = 1 ⇔ Γ ⊦ x : τ</p>
<pre><code>check(Γ, λx.y, α → β) = check(Γ ∪ x : α, y, β)

check(Γ, x, τ) = infer(Γ, x) == τ</code></pre>
<p><strong>Замечание.</strong> Для расширений λ-исчисления можно использовать аналогичный алгоритм, но в последней строке оператора <code>check</code> равенство типов имеет сложную структуру.</p>
<p>Подробнее можно поискать по запросу bidirectional typechecking и в каталоге code в репозитории с презентациями.</p>
</div>
</section><div><a class="slider-prev" href="#задачи-анализа-термов-λ-исчисления"></a><a class="slider-next" href="#метапеременные-и-унификация"></a></div>
<section id="метапеременные-и-унификация" class="slide level1">
<h1>Метапеременные и унификация</h1>
<p>В λ-исчислении с простыми типами (особенно в версии с аннотацией типов) приходится упоминать типы чаще, чем хотелось бы:</p>
<p>λ x<sub>α→β</sub>. (λ y<sub>(α→β)→(γ→δ)</sub>. y · x)</p>
<p>Разрешим вводить <strong>метапеременные</strong> типов — «прочерки», заполняемые в процессе проверки типов.</p>
<p>λ x<sub>α→β</sub> . λ y<sub>1→(γ→δ)</sub> . y · x</p>
<p>Задача <strong>унификации</strong> — для двух типов с метапеременными найти такую подстановку (набор значений метапеременных), что в результате подстановки типы будут эквивалентны.</p>
<p>1 ≡ α → β</p>
<p>Если эквивалентность типов тривиальна, то задача унификации разрешима.</p>
<p>Существует основанный на унификации более сложный алгоритм проверки типов (алгоритм Хиндли-Милнера), который не требует аннотаций. Описан, например, в <a href="https://compsciclub.ru/courses/types/2019-spring/classes/">курсе по ссылке.</a></p>
</section><div><a class="slider-prev" href="#двусторонний-алгоритм-проверки-типов"></a><a class="slider-next" href="#полиморфизм"></a></div>
<section id="полиморфизм" class="slide level1">
<h1>Полиморфизм</h1>
<h2 id="why-no-generics-in-λ">Why no generics in λ→?</h2>
<p>Аксиомы импликации A1 и A2 заданы в терминах λ-исчисления с простыми типами для фиксированных типов (высказываний) A, B, C. Для каждого нового типа (высказывания) нужно заново записывать эти аксиомы.</p>
<p>Функция идентичного преобразования id ≡ λx₁.x имеет отдельные несовместимые типы 1→1 для каждого типа x.</p>
<p><strong>Полиморфизм</strong> — свойство системы типов, согласно которому один терм может иметь сразу несколько различных типов.</p>
<p>Пример: тип полиморфной функции сортировки: ∀ α . (α → α → <strong>2</strong>) → List α → List α</p>
<p>Для определённых значений α: (int → int → <strong>2</strong>) → List int → List int</p>
<p>Композиция: f ∘ g ≡ g(f(x)) ≡ λf.λg.λx. g · (f · x) <span class="math inline">   </span>: <span class="math inline">   </span> ∀ α β γ. (β → γ) → (α → β) → α → γ</p>
</section><div><a class="slider-prev" href="#метапеременные-и-унификация"></a><a class="slider-next" href="#система-f-λ2"></a></div>
<section id="система-f-λ2" class="slide level1">
<h1>Система F (λ2)</h1>
<p>Жирар (1976), Рейнольдс (1974).</p>
<p>Тип τ ≡ α | α → β | ∀ α . τ <em>(добавим переменные и полиморфный тип)</em></p>
<p>Термы M = x <span class="math inline">   </span> | λ x : τ . M | M · N <span class="math inline">   </span> | Λ α . M | M · τ <em>(добавим абстракцию и применение типов)</em></p>
<p>Редукция: β-редукция и аналогичная ей ɩ-редукция для типов: (Λα.M) · τ ⟶<sub>ɩ</sub> M[α := τ].</p>
<p>В Coq ∀ записывается как <code>forall</code>, а между λ и Λ не делается различия.</p>
</section><div><a class="slider-prev" href="#полиморфизм"></a><a class="slider-next" href="#контексты"></a></div>
<section id="контексты" class="slide level1 inference">
<h1 class="inference">Контексты</h1>
<p>Для суждений типизации теперь нужно ввести понятие корректно сформированного (well-formed) контекста (т.е. контекста, в котором все переменные типов сначала объявляются, а затем уже используются):</p>
<p>Суждение Γ <strong>wf</strong>:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><span class="math inline">   </span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">[] wf</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Γ wf <span class="math inline">   </span> τ ∈ Γ</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Γ, x : τ wf</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Γ wf <span class="math inline">   </span> α не входит в типы в Γ</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Γ, α wf</td>
</tr>
</tbody>
</table>
<p>Для реализации проще обратиться к индексам де Брёйна для типов.</p>
<p>Существование типа (α : *) в корректно сформированном Γ:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Γ wf <span class="math inline">   </span> α ∈ Γ</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Γ ⊦ α : *</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">Γ wf <span class="math inline">   </span> Γ ⊦ α : * <span class="math inline">   </span> Γ ⊦ β : *</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Γ ⊦ α → β : *</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Γ, α wf <span class="math inline">   </span> Γ, α ⊦ β : *</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Γ ⊦ ∀α.β : *</td>
</tr>
</tbody>
</table>
</section><div><a class="slider-prev" href="#система-f-λ2"></a><a class="slider-next" href="#типизация"></a></div>
<section id="типизация" class="slide level1 inference">
<h1 class="inference">Типизация</h1>
<p>Правила типизации λ-исчисления с простыми типами (для абстракции и применения) входят в состав системы F, но только для корректно сформированных контекстов:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Γ, x : α wf</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Γ ⊦ x : α</td>
</tr>
</tbody>
</table>
<p>Правила типизации для полиморфных типов:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Γ ⊦ ∀ α . β : * <span class="math inline">   </span> Γ, α : * ⊦ M : β</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Γ ⊦ Λα.M : ∀α . β</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Γ ⊦ X : ∀α.β <span class="math inline">   </span> Γ ⊦ γ : *</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Γ ⊦ X · γ : β[α := γ]</td>
</tr>
</tbody>
</table>
</section><div><a class="slider-prev" href="#контексты"></a><a class="slider-next" href="#свойства-системы-f"></a></div>
<section id="свойства-системы-f" class="slide level1">
<h1>Свойства системы F</h1>
<ol type="1">
<li class="fragment">Для системы F выполняется свойство сильной нормализации (все корректно типизированные программы завершаются).</li>
<li class="fragment">Задачи анализа типов (проверки типа, вывода типа, обитаемости типа) для системы F без явных аннотаций типов <a href="https://www.sciencedirect.com/science/article/pii/S0168007298000475"><em>неразрешимы</em></a>.</li>
<li class="fragment">Эквивалентность типов разрешима.</li>
<li class="fragment">На практике используют двустороннюю проверку типов с аннотациями типов. Если проверка типов не завершилась за некоторое «разумное» время, нужно добавить дополнительную аннотацию типа.</li>
</ol>
</section><div><a class="slider-prev" href="#типизация"></a><a class="slider-next" href="#типы-данных-в-системе-f"></a></div>
<section id="типы-данных-в-системе-f" class="slide level1">
<h1>Типы данных в системе F</h1>
<p>Типы данных, которые вводились для λ-исчисления с простыми типами в форме отдельных правил типизации, в λ2 представимы без отдельных правил, чаще всего — путём <em>кодирования типа терма удаления</em>.</p>
<h2 id="пустой-тип-1">Пустой тип</h2>
<p>⊥ ≡ ∀α.α (exfalso)</p>
<h2 id="тривиальный-тип">Тривиальный тип</h2>
<p>T ≡ ∀α. α → α (тип функции идентичности) 1 ≡ Λα.λx.x</p>
<h2 id="тип-из-двух-элементов">Тип из двух элементов</h2>
<p><strong>2</strong> ≡ ∀α.α → α → α true ≡ Λα. λ x y. x <span class="math inline">   </span> false ≡ Λα. λ x y . y</p>
</section><div><a class="slider-prev" href="#свойства-системы-f"></a><a class="slider-next" href="#типы-данных-в-системе-f-1"></a></div>
<section id="типы-данных-в-системе-f-1" class="slide level1">
<h1>Типы данных в системе F</h1>
<h2 id="условный-оператор">Условный оператор</h2>
<p>if : ∀α. <strong>2</strong> → α → α → α if ≡ Λα. λ cond onTrue onFalse. cond · onTrue · onFalse</p>
<h2 id="произведение">Произведение</h2>
<p>A × B ≡ ∀α. (A → B → α) → α (a, b) ≡ Λα. λ f. f · a · b</p>
<h2 id="сумма">Сумма</h2>
<p>A + B ≡ ∀α. (A → α) → (B → α) → α inl a ≡ Λα.λf g. f · a <span class="math inline">   </span> inr b ≡ Λα.λf g. g · b</p>
</section><div><a class="slider-prev" href="#типы-данных-в-системе-f"></a><a class="slider-next" href="#типы-данных-в-системе-f-2"></a></div>
<section id="типы-данных-в-системе-f-2" class="slide level1">
<h1>Типы данных в системе F</h1>
<h2 id="нумерал-чёрча-натуральные-числа">Нумерал Чёрча (натуральные числа)</h2>
<p>ℕ ≡ ∀α. α → (α → α) → α</p>
<p>0 ≡ Λα. λz s. z</p>
<p>x+1 ≡ λx. Λα. λ z s. s · (n · α · z · s)</p>
<p>Натуральные числа задают понятие итерации.</p>
<h2 id="полиморфный-список-">Полиморфный список (!)</h2>
<p>List β ≡ ∀β. ∀ α. α → (β → α → α) → α</p>
<p>[] ≡ Λα. λx. λf. x</p>
<p>head ; Tail ≡ Λβ. Λα. λ Tail<sub>List<span class="math inline"> </span>β</sub>. λ headᵦ . λ x . λ f . Tail · x · (f · head · x)</p>
<p>Сравните определение нумералов и списка.</p>
<p>Аналогично — деревья и другие индуктивные структуры данных.</p>
</section><div><a class="slider-prev" href="#типы-данных-в-системе-f-1"></a><a class="slider-next" href="#соответствие-карри-говарда"></a></div>
<section id="соответствие-карри-говарда" class="slide level1">
<h1>Соответствие Карри-Говарда</h1>
<p>Исчисление высказываний представимо в системе F в терминах соответствия Карри-Говарда (аналогично λ-исчислению с простыми типами).</p>
<p>Дополнительно представимы кванторы по типам: ∀α.β</p>
<p>Квантор существования: ∃α.τ ≡ ∀β. (∀α . τ → β) → β</p>
</section><div><a class="slider-prev" href="#типы-данных-в-системе-f-2"></a><a class="slider-next" href="#задачи"></a></div>
<section id="задачи" class="slide level1">
<h1>Задачи</h1>
<dl>
<dt class="fragment"><strong>Задача 6.1. *</strong></dt>
<dd class="fragment">Вывести в λ-исчислении с простыми типами, дополненном типами данных, аксиомы исчисления высказываний для конъюнкции, дизъюнкции и для отрицания, кроме аксиомы двойного отрицания или исключенного третьего.
</dd>
</dl>
<p>Результатом задачи 6.1 будет доказательство того факта, что любая выводимая формула исчисления высказываний соответствует типу для λ-исчисления с простыми типами, дополненного типами данных.</p>
<dl>
<dt class="fragment"><strong>Задача 6.2. *</strong></dt>
<dd class="fragment">Реализовать в системе F сортировку списка булевских значений <strong>2</strong>.
</dd>
<dt class="fragment"><strong>Задача 6.3. **</strong></dt>
<dd class="fragment">Доказать, что аксиома двойного отрицания или аксиома исключённого третьего невыводима в λ-исчислении с простыми типами, дополненном типами данных.
</dd>
</dl>
</section><div><a class="slider-prev" href="#соответствие-карри-говарда"></a><a class="slider-next" href="#задачи-1"></a></div>
<section id="задачи-1" class="slide level1">
<h1>Задачи</h1>
<p>Для программ, которые являются решением задач 6.4, входом является пара строк — терм λ-исчисления, записанного в синтаксисе на ваш выбор (но в таком, чтобы можно было записать достаточно сложные примеры) и тип. Выходом является ответ «да» (терм имеет заданный тип) или «нет» (терм не имеет заданный тип). К решению должно прилагаться несколько нетривиальных примеров входов, как с положительным так и с отрицательным результатом проверки.</p>
<dl>
<dt class="fragment"><strong>Задача 6.4а. **</strong></dt>
<dd class="fragment">Реализовать проверку типов для λ-исчисления с простыми типами, дополненного типами данных.
</dd>
<dt class="fragment"><strong>Задача 6.4б. ***</strong></dt>
<dd class="fragment">Реализовать проверку типов для системы F (полиморфного λ-исчисления).
</dd>
</dl>
</section><div><a class="slider-prev" href="#задачи"></a><a class="slider-next" href="#задачи-2"></a></div>
<section id="задачи-2" class="slide level1">
<h1>Задачи</h1>
<dl>
<dt class="fragment"><strong>Задача 6.4в. ****</strong></dt>
<dd class="fragment">Реализовать проверку типов для системы <span class="math inline"><em>F</em><sub><em>ω</em></sub></span> (полиморфного λ-исчисления с конструкторами типов).
</dd>
</dl>
<p>Бонусные ** к задачам 6.4 — реализовать транслятор из простого императивного языка программирования в набор термов и проверку типов для программ на таком языке.</p>
</section><div><a class="slider-prev" href="#задачи-1"></a><a class="slider-next"></a></div>

<!-- start page -->
   <div id="slider">
       <a href="#математические-модели-вычислений" class="slider-start">PLAY</a>
   </div>

   <!-- progressbar container -->
   <div class="slider-progress"></div>
   </article>
  </div>

  
  <script type="text/javascript">
  document.addEventListener("keydown", function(e) {
     if (e.altKey || e.ctrlKey || e.metaKey || e.shiftKey) { return; }
     switch (e.keyCode) {
       case 35: // End
          var arr = document.querySelectorAll("a.slider-next:link");
          var a = arr[arr.length - 1];
          if (a && a.href) {
            window.location = a.href;
          }
          break;
       case 36: // Home
          var a = document.querySelector("a.slider-start");
          if (a && a.href) {
            window.location = a.href;
          }
          break;
       case 37: // left arrow
         var a = document.querySelector("section:target ~ div a.slider-prev");
         if (a && a.href) {
           window.location = a.href;
         }
         break;
       case 39: // right arrow
         var a = document.querySelector("section:target ~ div a.slider-next");
         if (a && a.href) {
           window.location = a.href;
         }
         break;
     }
  });
  </script>
  

</body></html>

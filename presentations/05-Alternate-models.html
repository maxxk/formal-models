<!DOCTYPE html><html><head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title></title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="slider.css">
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
  <div style="width: 640px;height: 400px;">
  <input id="slider-max" type="checkbox" checked="">
   <article class="slider slider-indicator">
   <a id="slider-default"></a>
   <label for="slider-max" title="Maximize"></label>


<section id="математические-модели-вычислений" class="slide level1">
<h1>Математические модели вычислений</h1>
<h2 id="альтернативные-модели-вычислений">Альтернативные модели вычислений</h2>
<h3 id="клеточные-автоматы">Клеточные автоматы</h3>
<h3 id="понятие-тьюринг-полноты-в-компьютерных-языках">Понятие «Тьюринг-полноты» в компьютерных языках</h3>
<h3 id="μ-рекурсивные-функции-клини">μ-рекурсивные функции Клини</h3>
<h3 id="операторные-схемы-программ">Операторные схемы программ</h3>
<h3 id="схемы-янова">Схемы Янова</h3>
<h4 id="maxim.krivchikovgmail.com"><a href="mailto:maxim.krivchikov@gmail.com" class="email">maxim.krivchikov@gmail.com</a></h4>
<h4 id="httpsmaxxk.github.ioformal-models"><a href="https://maxxk.github.io/formal-models/" class="uri">https://maxxk.github.io/formal-models/</a></h4>
<style>
.inference table {
    display: inline-block;
    padding: 1em;
}

.inference table th {
    font-weight: normal;
    border-bottom: 1px solid black;
}
</style>
</section><div><a class="slider-prev"></a><a class="slider-next" href="#клеточный-автомат"></a></div>
<section id="клеточный-автомат" class="slide level1">
<h1>Клеточный автомат</h1>
<p>Решётка («таблица» произвольной размерности) из ячеек, каждая из которых может находиться в конечном числе состояний.</p>
<p>На каждом шаге следующее состояние каждой ячейки определяется по заданному фиксированному правилу, которое может использовать текущее состояние ячейки и текущие состояния ячеек в некоторой окрестности.</p>
<p>Более строго:</p>
<ol type="1">
<li class="fragment">Пространство ячеек C.</li>
<li class="fragment">Конечный набор возможных состояний ячеек — Σ, |Σ| = k; ∀ c ∈ C, σ(c) ∈ Σ.</li>
<li class="fragment">Понятие окрестности ячейки — N(c) — конечное множество ячеек из C. Для всех ячеек окрестность имеет один и тот же размер |N(c)| = n. Окрестность «взаимна» — для каждой ячейки d из окрестности ячейки c, c ∈ N(d).</li>
<li class="fragment">Правило перехода φ : Σ<sup>n</sup> → Σ.</li>
</ol>
<p>На каждом шаге t правило перехода одновременно применяется к каждой ячейке с состояниями окрестности на предыдущий момент времени t-1.</p>
</section><div><a class="slider-prev" href="#математические-модели-вычислений"></a><a class="slider-next" href="#типы-поведения-автоматов"></a></div>
<section id="типы-поведения-автоматов" class="slide level1">
<h1>Типы поведения автоматов</h1>
<p>Классификация правил перехода Вольфрама:</p>
<p><strong>Класс 1.</strong> Быстрая стабилизация состояния и его гомогенность.<br>
<strong>Класс 2.</strong> Быстрая стабилизация состояния либо возникновение колебаний. Локальные изменения в начальных условиях оказывают локальный характер на дальнейший ход эволюции системы.<br>
<strong>Класс 3.</strong> Почти все начальные условия приводят к псевдо-случайным последовательностям, стабильные структуры почти сразу уничтожаются окружающим шумом.<br>
<strong>Класс 4.</strong> Результатом эволюции почти всех начальных состояний являются структуры, которые взаимодействуют сложным образом с формированием локальных, устойчивых структур, которые способны сохраняться длительное время.</p>
<p>Некоторые клеточные автоматы демонстрируют поведение, достаточное для эмуляции машины Тьюринга.</p>
<p><em>Литература: Клеточные автоматы: Stephen Wolfram. A New Kind of Science. Wolfram Media, Inc. 2007</em></p>
</section><div><a class="slider-prev" href="#клеточный-автомат"></a><a class="slider-next" href="#тьюринг-эквивалентные-клеточные-автоматы"></a></div>
<section id="тьюринг-эквивалентные-клеточные-автоматы" class="slide level1">
<h1>Тьюринг-эквивалентные клеточные автоматы</h1>
<ol type="1">
<li class="fragment"><a href="http://www.igblan.free-online.co.uk/igblan/ca/">Игра «Жизнь» Конвэя</a> (<a href="http://www.rendell-attic.org/gol/fullutm/index.htm">и ещё одна схема</a>)</li>
<li class="fragment">«Rule 110» — одномерный клеточный автомат</li>
</ol>
<p>Дополнительно:</p>
<ol type="1">
<li class="fragment">Эмулятор двумерного клеточного автомата: <a href="http://golly.sourceforge.net/" class="uri">http://golly.sourceforge.net/</a></li>
<li class="fragment">Эмулятор игры Тетрис в игре "Жизнь": <a href="https://codegolf.stackexchange.com/q/11880" class="uri">https://codegolf.stackexchange.com/q/11880</a></li>
<li class="fragment">Универсальная машина Тьюринга в игре "Жизнь": <a href="http://rendell-attic.org/gol/utm/index.htm" class="uri">http://rendell-attic.org/gol/utm/index.htm</a></li>
</ol>
</section><div><a class="slider-prev" href="#типы-поведения-автоматов"></a><a class="slider-next" href="#rule-110"></a></div>
<section id="rule-110" class="slide level1">
<h1>Rule 110</h1>
<p>Из Wolfram MathWorld: <a href="http://mathworld.wolfram.com/Rule110.html" class="uri">http://mathworld.wolfram.com/Rule110.html</a><br>
<img src="images/ElementaryCARule110_1000.gif"></p>
</section><div><a class="slider-prev" href="#тьюринг-эквивалентные-клеточные-автоматы"></a><a class="slider-next" href="#понятие-тьюринг-полноты-в-компьютерных-языках-1"></a></div>
<section id="понятие-тьюринг-полноты-в-компьютерных-языках-1" class="slide level1">
<h1>Понятие «Тьюринг-полноты» в компьютерных языках</h1>
</section><div><a class="slider-prev" href="#rule-110"></a><a class="slider-next" href="#машины-с-регистрами"></a></div>
<section id="машины-с-регистрами" class="slide level1">
<h1>Машины с регистрами</h1>
<p>Машина с регистрами включает:</p>
<ol type="1">
<li class="fragment">Неограниченное (как правило, конечное) количество именованных регистров, каждый из которых может содержать одно неотрицательное число неограниченного размера.</li>
<li class="fragment">Набор меток.</li>
<li class="fragment">Ограниченный набор инструкций, который может включать:
<ol type="1">
<li class="fragment">Арифметические инструкции (Increment(r), Decrement(r), Clear-to-zero(r), Load-constant(r, k), Add, Subtract, ...)</li>
<li class="fragment">Управляющие инструкции (Copy(r<sub>1</sub>, r<sub>2</sub>), LoadAccumulator(r), StoreAccumulator(r))</li>
<li class="fragment"><strong>Условный переход</strong> (обязательно; как правило, по заданному регистру): Jump-if-zero, Jump-if-not-zero, Jump-if-equal, ...</li>
<li class="fragment">Операции непрямой адресации (Load-from-address(r), Store-by-address(r))</li>
<li class="fragment">Ввод-вывод</li>
</ol></li>
<li class="fragment">Регистр состояний — содержит текущую инструкцию и её адрес в программе.</li>
<li class="fragment">Список инструкций с метками (как правило, последовательный).</li>
</ol>
<p>Классы: машины со счётчиками, машины с указателями, машины с памятью с произвольным доступом, машины с памятью с произвольным доступом с программой в регистрах (архитектура фон Неймана)</p>
</section><div><a class="slider-prev" href="#понятие-тьюринг-полноты-в-компьютерных-языках-1"></a><a class="slider-next" href="#аппаратные-реализации"></a></div>
<section id="аппаратные-реализации" class="slide level1">
<h1>«Аппаратные» реализации</h1>
<ol type="1">
<li class="fragment">URISC (Ultimate Restricted Instruction Set Computer) — машина с одной инструкцией. Для того, чтобы иметь возможность эмулировать машину Тьюринга, память должна быть бесконечной, а адреса и ячейки — произвольными целыми числами (возможно, неотрицательными)
<ul>
<li class="fragment"><code>subleq a, b, c</code> — посчитать <code>M[b] - M[a]</code>, записать в <code>M[b]</code> и, если <code>b ≤ 0</code> перейти на адрес <code>c</code>. В памяти хранятся тройки <code>a, b, c</code></li>
<li class="fragment"><code>dln a, b</code> — уменьшить на 1 значение <code>M[a]</code>; если получился <code>0</code>, перейти по адресу <code>b</code></li>
</ul></li>
<li class="fragment"><p>Механизм защиты памяти в x86-процессорах допускает реализацию <code>subleq</code> с помощью вложенных исключений page fault</p></li>
<li class="fragment"><p>Magic: The Gathering (и другие примеры на странице <a href="http://beza1e1.tuxen.de/articles/accidentally_turing_complete.html">Accidentally Turing-complete</a>)</p></li>
</ol>
</section><div><a class="slider-prev" href="#машины-с-регистрами"></a><a class="slider-next" href="#μ-рекурсивные-функции-клини-1"></a></div>
<section id="μ-рекурсивные-функции-клини-1" class="slide level1">
<h1>μ-рекурсивные функции Клини</h1>
<p>Частично-рекурсивные функции на натуральных числах.</p>
<h2 id="функции">Функции</h2>
<ol type="1">
<li class="fragment">k-арные константные функции K<sup>k</sup><sub>n</sub>.</li>
</ol>
<p>K<sup>k</sup><sub>n</sub>(x<sub>1</sub>, …, x<sub>k</sub>) = n</p>
<ol start="2" type="1">
<li class="fragment">1-арная функция увеличения на 1</li>
</ol>
<p>S(x) = x + 1</p>
<ol start="3" type="1">
<li class="fragment">Функции проекции P<sup>k</sup><sub>i</sub><br>
P<sup>k</sup><sub>i</sub>(x<sub>1</sub>, …, x<sub>k</sub>) = x<sub>i</sub></li>
</ol>
<h2 id="операторы">Операторы</h2>
<ol type="1">
<li class="fragment">Оператор подстановки ∘ для m-арной функции h и m k-арных функций g<sub>i</sub> определяет k-арную функцию</li>
</ol>
<p>h ∘ (g<sub>1</sub>, …, g<sub>m</sub>) = f(x<sub>1</sub>, …, x<sub>k</sub>)</p>
<p>f = h(g<sub>1</sub>(x<sub>1</sub>, …, x<sub>k</sub>), …, g<sub>m</sub>(x<sub>1</sub>, …, x<sub>k</sub>))</p>
</section><div><a class="slider-prev" href="#аппаратные-реализации"></a><a class="slider-next" href="#μ-рекурсивные-функции-клини-2"></a></div>
<section id="μ-рекурсивные-функции-клини-2" class="slide level1">
<h1>μ-рекурсивные функции Клини</h1>
<h2 id="операторы-1">Операторы</h2>
<ol start="2" type="1">
<li class="fragment">Оператор примитивной рекурсии («цикл») <span class="math inline"><em>ρ</em>(<em>g</em>, <em>h</em>)</span> по k-арной функции <span class="math inline"><em>g</em></span> (база индукции) и k+2-арной функции h (шаг индукции) определяет k-арную функцию <span class="math inline"><em>f</em></span>:</li>
</ol>
<p>f(0, x<sub>1</sub>, …, x<sub>k</sub>) = g(x~1, …, x<sub>k</sub>)</p>
<p>f(y+1, x<sub>1</sub>, …, x<sub>k</sub>) = h(y, f(y, x<sub>1</sub>, …, x<sub>k</sub>), x<sub>1</sub>, …, x<sub>k</sub>)</p>
<p>Первые два аргумента h — число итераций и результат предыдущей итерации.</p>
<ol start="3" type="1">
<li class="fragment">Оператор минимизации <span class="math inline"><em>μ</em></span> для k+1-арной полной функции f возвращает k-арную частичную функцию, которая находит минимальное значение первого аргумента <span class="math inline"><em>z</em></span>, при котором f(z, x<sub>1</sub>, …, x<sub>k</sub>) = 0:</li>
</ol>
<p>μ(f)(x<sub>1</sub>, …, x<sub>k</sub>) = z : f(z, x<sub>1</sub>, …, x<sub>k</sub>) = 0; f(i &lt; z, x<sub>1</sub>, …, x<sub>k</sub>) &gt; 0</p>
</section><div><a class="slider-prev" href="#μ-рекурсивные-функции-клини-1"></a><a class="slider-next" href="#операторная-схема-программы"></a></div>
<section id="операторная-схема-программы" class="slide level1">
<h1>Операторная схема программы</h1>
<p>Классический советский подход к теории программирования, предложенный А.А. Ляпуновым в первом курсе «Принципы программирования», который он читал в 1952/53 году на кафедре вычислительной математики.</p>
<p>В более позднем определении А.П. Ершова:</p>
<p>Задано конечное множество <em>операторов</em> F = { F<sub>1</sub>, …, F<sub>n</sub>}. Входы и выходы описываются в терминах <em>полюсов</em> операторов P = A ∪ R — объединение непересекающихся множеств <em>аргументов</em> A = {a<sub>1</sub>, …, a<sub>p</sub>} и <em>результатов</em> R = { r<sub>1</sub>, …, r<sub>q</sub> }. <em>Распределение полюсов</em> — отображение V : P → F.</p>
<p><em>Граф переходов</em> — ориентированный граф C = (F, J), где J — бинарное отношение, задающее для оператора его преемников по передаче управления.<br>
Компоненты связности графа переходов — отдельные программы в программном комплексе.</p>
<p><em>Скелет</em> программы — набор перечисленных множеств S = (F, C, A, R, V).</p>
<p><em>Память</em> описывается множеством X = { x<sub>1</sub>, …, x<sub>m</sub> } и распределяется среди полюсов отображением L : P → X.</p>
<p>Операторная схема программы — набор G = (S, X, L).</p>
</section><div><a class="slider-prev" href="#μ-рекурсивные-функции-клини-2"></a><a class="slider-next" href="#задача-экономии-памяти"></a></div>
<section id="задача-экономии-памяти" class="slide level1">
<h1>Задача экономии памяти</h1>
<p>А.П. Ершов в книге (ссылка ниже) рассматривает задачу экономии памяти: каким образом можно использовать минимальное множество памяти X, сохраняя семантику программы?</p>
<p>Постановка задачи: по заданной схеме программы с <em>распределением памяти</em> L построить новое распределение памяти L', использующее, по возможности, память меньшего объёма.</p>
<p>А. П. Ершов. Введение в теоретическое программирование: беседы о методе. М.: Наука, 1977. 288 С.</p>
</section><div><a class="slider-prev" href="#операторная-схема-программы"></a><a class="slider-next" href="#задача-экономии-памяти-1"></a></div>
<section id="задача-экономии-памяти-1" class="slide level1">
<h1>Задача экономии памяти</h1>
<p><em>Информационный граф</em> I = (P, M) — двудольный граф M ⊂ R×A, который сопоставляет результаты оператора с аргументами его преемников. <em>Маршрут информационной связи</em> — путь в информационном графе, задаётся первым результатом и последним аргументом.</p>
<p>Компоненты связности информационного графа называются <em>областями действия</em>.</p>
<p>Области действия <em>несовместимы</em> тогда и только тогда, когда в каждой из них найдутся результаты r и r', соответственно, такие, что:</p>
<ul>
<li class="fragment">V(r) = V(r') или</li>
<li class="fragment">V(r) — внутренний оператор маршрута информационной связи (r', a')</li>
<li class="fragment">V(r') — внутренний оператор маршрута информационной связи (r, a)</li>
</ul>
<p>Задача экономии памяти решается выделением несовместимых областей действия раскраской графа и объединением совместимых областей действия.</p>
</section><div><a class="slider-prev" href="#задача-экономии-памяти"></a><a class="slider-next" href="#схема-янова"></a></div>
<section id="схема-янова" class="slide level1">
<h1>Схема Янова</h1>
<p>Модификация операторной схемы программ.<br>
Область приложения — исследование способов задания условий в программе и эквивалентных преобразований программ с условиями.</p>
<p>Не рассматривается понятие памяти и распределения памяти. Все операторы одноместны, принимают на вход исходное состояние памяти и возвращают полностью изменённое состояние.</p>
<p>Вводятся счётные множества <em>предикатных символов</em> <strong>P</strong> = { p<sub>1</sub>, p<sub>2</sub>, … } и <em>операторных символов</em> <strong>A</strong> = { A<sub>1</sub>, A<sub>2</sub>, … }.</p>
<p><em>Оператор</em> A = A(P) — пара из операторного символа A и некоторого (возможно, пустого) множества предикатных символов P, которое называется <em>сдвигом</em> оператора A.</p>
</section><div><a class="slider-prev" href="#задача-экономии-памяти-1"></a><a class="slider-next" href="#схема-янова-1"></a></div>
<section id="схема-янова-1" class="slide level1">
<h1>Схема Янова</h1>
<p><em>Граф переходов</em> — ориентированный граф, множество вершин которого состоит из неотрицательного числа <em>преобразователей</em>, <em>распознавателей</em> и одного <em>останова</em>. Из преобразователя выходит в точности одна дуга, из распознавателя — две различные (<em>плюс-стрелка</em> и <em>минус-стрелка</em>). Выделяется одна <em>входная</em> вершина графа и помечается <em>входной стрелкой</em>.</p>
<p><em>Преобразователи</em> помечены операторными символами, <em>распознаватели</em> помечены логическими формулами над <em>предикатными</em> символами.</p>
<p><em>Схема Янова</em> G(p<sub>1</sub>, …, p<sub>k</sub>)</p>
</section><div><a class="slider-prev" href="#схема-янова"></a><a class="slider-next" href="#схема-янова-2"></a></div>
<section id="схема-янова-2" class="slide level1">
<h1>Схема Янова</h1>
<p><img src="images/Yanov_schemata.gif"></p>
</section><div><a class="slider-prev" href="#схема-янова-1"></a><a class="slider-next" href="#семантика-схемы-янова"></a></div>
<section id="семантика-схемы-янова" class="slide level1">
<h1>Семантика схемы Янова</h1>
<p>Для того, чтобы схема задавала программу, необходимо дать <em>интерпретацию</em> операторным и предикатным символам, и описать алгоритм выполнения интерпретированной схемы.</p>
<p>Дано некоторое множество <em>состояний памяти</em> D.<br>
Предикатные символы p<sub>i</sub> соответствуют предикатам π<sub>i</sub> : D → { <strong>f</strong>, <strong>t</strong> }. Сами p<sub>i</sub> в программе назовём <em>предикатными переменными</em>.</p>
<p>Операторным символам A<sub>j</sub> сопоставляются (возможно, частичные) функции φ<sub>j</sub> : D → D</p>
</section><div><a class="slider-prev" href="#схема-янова-2"></a><a class="slider-next" href="#выполнение-схемы-янова"></a></div>
<section id="выполнение-схемы-янова" class="slide level1">
<h1>Выполнение схемы Янова</h1>
<p><strong>Начальный шаг.</strong> Берём произвольное d ∈ D в качестве исходного состояния памти и присваиваем значения всем предикатным переменным p<sub>i</sub> ≡ π<sub>i</sub>(d). Передаём управление на входную вершину графа переходов.</p>
<p><strong>Шаг выполнения.</strong> Пусть d — текущее состояние памяти, Δ = (σ<sub>1</sub>, …, σ<sub>k</sub>) — текущие значения предикатных переменных, S — текущая вершина графа переходов.</p>
<ol type="1">
<li class="fragment">Если S — останов, то выполнение завершается, и d является результатом выполнения схемы в данной интерпретации.</li>
<li class="fragment">Если S — распознаватель с условием F(p<sub>1</sub>, …, p<sub>k</sub>). Вычисляем σ = F(Δ) и передаём управление по плюс-стрелке, если σ=<strong>t</strong> и по минус-стрелке, если σ=<strong>f</strong>.</li>
<li class="fragment">Если S — преобразователь A<sub>j</sub>(P<sub>j</sub>), вычисляем новое состояние памяти d' = φ<sub>j</sub>(d) и значения предикатных переменных в сдвиге P<sub>j</sub> : p<sub>i</sub> ≡ π<sub>i</sub>(d'). Управление передаётся на следующую вершину графа.</li>
</ol>
<p>Таким образом, получена частичная функция d = <strong>F</strong><sub>G,I</sub>(d<sub>0</sub>).</p>
</section><div><a class="slider-prev" href="#семантика-схемы-янова"></a><a class="slider-next" href="#эквивалентность-схем"></a></div>
<section id="эквивалентность-схем" class="slide level1">
<h1>Эквивалентность схем</h1>
<p>Схемы G<sub>1</sub> и G<sub>2</sub> <em>сравнимы</em>, если они заданы над одним и тем же множеством предикатных символов, а также у одинаковых операторов совпадают сдвиги.</p>
<p>Две сравнимые схемы <em>эквивалентны</em> в некоторой совместной интерпретации I, если F<sub>G1,I</sub>(d) = F<sub>G2,I</sub>(d).</p>
<p>Две сравнимые схемы <em>функционально эквивалентны</em>, если они эквивалентны в любой совместной интерпретации.</p>
<p><em>Операционная история</em> (след) интерпретированной схемы Янова H<sub>G,I</sub>(d) — полная последовательность выполняемых операторов и наборов значений функциональных переменных. Для исключения циклов вершины графа помечаются наборами значений предикатных переменных. Если при выполнении мы попали в вершину, помеченную таким же набором значений, что и текущий набор Δ, считаем, что мы попали в бесконечный цикл.</p>
<p>Две сравнимые схемы <em>операционно эквивалентны</em>, если они одинаково работают в любой совместной интерпретации, т.е.<br>
H<sub>G1,I</sub>(d) = H<sub>G2,I</sub>(d).</p>
<p><strong>Теорема.</strong> Функциональная эквивалентность равносильна операционной эквивалентности.</p>
</section><div><a class="slider-prev" href="#выполнение-схемы-янова"></a><a class="slider-next" href="#эквивалентность-схем-1"></a></div>
<section id="эквивалентность-схем-1" class="slide level1">
<h1>Эквивалентность схем</h1>
<p><em>Конфигурации</em> схемы k ∈ K(G) строятся аналогично операционным историям, но без заданной интерпретации индуктивно:</p>
<p><strong>Начальный шаг.</strong> Выберем произвольный набор исходных значений предикатных переменных Δ.<br>
<strong>Очередной шаг.</strong> Текущий набор Δ, текущая вершина S. Уже обработанные вершины помечены.</p>
<ol type="1">
<li class="fragment">Если S — помеченный распознаватель, то мы попали в пустой цикл и конфигурация не может быть построена.</li>
<li class="fragment">Если S — непомеченный распознаватель с условием F, помечаем его, вычисляем F(Δ) и переходим к вершине-преемнику.</li>
<li class="fragment">Если S — останов, построение конфигурации завершено.</li>
<li class="fragment">Если S — оператор, то записываем A<sub>i</sub> в конфигурацию, и в качестве нового значения Δ' помещаем произвольный набор, образующий с набором Δ допустимую пару для оператора A<sub>i</sub>.</li>
</ol>
<p>Две сравнимые схемы <em>формально эквивалентны</em>, если их множества их конфигураций совпадают.</p>
<p><strong>Теорема.</strong> Функциональная эквивалентность равносильна формальной эквивалентности.</p>
</section><div><a class="slider-prev" href="#эквивалентность-схем"></a><a class="slider-next" href="#эквивалентные-преобразования"></a></div>
<section id="эквивалентные-преобразования" class="slide level1">
<h1>Эквивалентные преобразования</h1>
<p>Вводится набор из 13 аксиом и 5 правил вывода, определяющий все примитивные эквивалентные преобразования схем Янова.</p>
<p><strong>Теорема.</strong> Для любых двух эквивалентных схем Янова можно построить последовательность эквивалентных преобразований, которые приводят их к общему виду.</p>
<p><strong>Теорема.</strong> Задача эквивалентности двух сравнимых схем Янова разрешима.</p>
</section><div><a class="slider-prev" href="#эквивалентность-схем-1"></a><a class="slider-next" href="#задачи"></a></div>
<section id="задачи" class="slide level1">
<h1>Задачи</h1>
<dl>
<dt class="fragment"><strong>Задача 5.1*</strong></dt>
<dd class="fragment">реализуйте интерпретатор <span class="math inline"><em>μ</em></span>-рекурсивных функций Клини с возможностью пошагового выполнения.
</dd>
<dt class="fragment"><strong>Задача 5.2**</strong></dt>
<dd class="fragment">реализуйте проверку числа на простоту в терминах μ-рекурсивных функций Клини.
</dd>
<dt class="fragment"><strong>Задача 5.3*</strong></dt>
<dd class="fragment">реализуйте интерпретатор произвольных клеточных автоматов с "квадратными" клетками, в качестве примера покажите работоспособную реализацию игры "жизнь".
</dd>
<dt class="fragment"><strong>Задача 5.4***</strong></dt>
<dd class="fragment">предложите возможные способы задания системы типов, не допускающей задание незавершимых функций, для клеточных автоматов или для μ-рекурсивных функций Клини (текст, от 5 страниц A4, шрифт 14пт, междустрочный интервал 1.5).
</dd>
<dt class="fragment"><strong>Задача 5.5**</strong></dt>
<dd class="fragment">опишите в терминах схем Янова один из алгоритмов сортировки списка и докажите его корректность.
</dd>
</dl>
</section><div><a class="slider-prev" href="#эквивалентные-преобразования"></a><a class="slider-next"></a></div>

<!-- start page -->
   <div id="slider">
       <a href="#математические-модели-вычислений" class="slider-start">PLAY</a>
   </div>

   <!-- progressbar container -->
   <div class="slider-progress"></div>
   </article>
  </div>

  
  <script type="text/javascript">
  document.addEventListener("keydown", function(e) {
     if (e.altKey || e.ctrlKey || e.metaKey || e.shiftKey) { return; }
     switch (e.keyCode) {
       case 35: // End
          var arr = document.querySelectorAll("a.slider-next:link");
          var a = arr[arr.length - 1];
          if (a && a.href) {
            window.location = a.href;
          }
          break;
       case 36: // Home
          var a = document.querySelector("a.slider-start");
          if (a && a.href) {
            window.location = a.href;
          }
          break;
       case 37: // left arrow
         var a = document.querySelector("section:target ~ div a.slider-prev");
         if (a && a.href) {
           window.location = a.href;
         }
         break;
       case 39: // right arrow
         var a = document.querySelector("section:target ~ div a.slider-next");
         if (a && a.href) {
           window.location = a.href;
         }
         break;
     }
  });
  </script>
  

</body></html>

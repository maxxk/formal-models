<!DOCTYPE html><html><head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title>03-Alternate-models</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="slider.css">
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
  <div style="width: 640px;height: 400px;" id="container">
  <input id="slider-max" type="checkbox" checked="">
   <article class="slider slider-indicator" id="main">
   <a id="slider-default"></a>
   <label title="Flat view" id="flat-view"></label>


<section id="математические-модели-вычислений" class="slide level1">
<h1>Математические модели вычислений</h1>
<h2 id="альтернативные-модели-вычислений">Альтернативные модели
вычислений</h2>
<h3 id="клеточные-автоматы">Клеточные автоматы</h3>
<h3 id="понятие-тьюринг-полноты-в-компьютерных-языках">Понятие
«Тьюринг-полноты» в компьютерных языках</h3>
<h3 id="μ-рекурсивные-функции-клини">μ-рекурсивные функции Клини</h3>
<h3 id="операторные-схемы-программ">Операторные схемы программ</h3>
<h3 id="схемы-янова">Схемы Янова</h3>
<h4 id="maximkrivchikovgmailcom"><a href="mailto:maxim.krivchikov@gmail.com" class="email">maxim.krivchikov@gmail.com</a></h4>
<h4 id="httpsmaxxkgithubioformal-models"><a href="https://maxxk.github.io/formal-models/" class="uri">https://maxxk.github.io/formal-models/</a></h4>
<style>
.inference table {
    display: inline-block;
    padding: 1em;
}

.inference table th {
    font-weight: normal;
    border-bottom: 1px solid black;
}
</style>
</section><div><a class="slider-prev"></a><a class="slider-next" href="#клеточный-автомат"></a></div>
<section id="клеточный-автомат" class="slide level1">
<h1>Клеточный автомат</h1>
<p>Решётка («таблица» произвольной размерности) из ячеек, каждая из
которых может находиться в конечном числе состояний.</p>
<p>На каждом шаге следующее состояние каждой ячейки определяется по
заданному фиксированному правилу, которое может использовать текущее
состояние ячейки и текущие состояния ячеек в некоторой окрестности.</p>
<p>Более строго:</p>
<ol type="1">
<li class="fragment">Пространство ячеек C.</li>
<li class="fragment">Конечный набор возможных состояний ячеек — Σ, |Σ| =
k; ∀ c ∈ C, σ(c) ∈ Σ.</li>
<li class="fragment">Понятие окрестности ячейки — N(c) — конечное
множество ячеек из C. Для всех ячеек окрестность имеет один и тот же
размер |N(c)| = n. Окрестность «взаимна» — для каждой ячейки d из
окрестности ячейки c, c ∈ N(d).</li>
<li class="fragment">Правило перехода φ : Σ<sup>n</sup> → Σ.</li>
</ol>
<p>На каждом шаге t правило перехода одновременно применяется к каждой
ячейке с состояниями окрестности на предыдущий момент времени t-1.</p>
</section><div><a class="slider-prev" href="#математические-модели-вычислений"></a><a class="slider-next" href="#типы-поведения-автоматов"></a></div>
<section id="типы-поведения-автоматов" class="slide level1">
<h1>Типы поведения автоматов</h1>
<p>Классификация правил перехода Вольфрама:</p>
<p><strong>Класс 1.</strong> Быстрая стабилизация состояния и его
гомогенность.</p>
<p><strong>Класс 2.</strong> Быстрая стабилизация состояния либо
возникновение колебаний. Локальные изменения в начальных условиях
оказывают локальный характер на дальнейший ход эволюции системы.</p>
<p><strong>Класс 3.</strong> Почти все начальные условия приводят к
псевдо-случайным последовательностям, стабильные структуры почти сразу
уничтожаются окружающим шумом.</p>
<p><strong>Класс 4.</strong> Результатом эволюции почти всех начальных
состояний являются структуры, которые взаимодействуют сложным образом с
формированием локальных, устойчивых структур, которые способны
сохраняться длительное время.</p>
<p>Некоторые клеточные автоматы демонстрируют поведение, достаточное для
эмуляции машины Тьюринга.</p>
<p><em>Литература: Клеточные автоматы: Stephen Wolfram. A New Kind of
Science. Wolfram Media, Inc. 2007</em></p>
</section><div><a class="slider-prev" href="#клеточный-автомат"></a><a class="slider-next" href="#тьюринг-эквивалентные-клеточные-автоматы"></a></div>
<section id="тьюринг-эквивалентные-клеточные-автоматы" class="slide level1">
<h1>Тьюринг-эквивалентные клеточные автоматы</h1>
<ol type="1">
<li class="fragment"><a href="http://www.igblan.free-online.co.uk/igblan/ca/">Игра «Жизнь»
Конвэя</a> (<a href="http://www.rendell-attic.org/gol/fullutm/index.htm">и ещё одна
схема</a>)</li>
<li class="fragment">«Rule 110» — одномерный клеточный автомат</li>
</ol>
<p>Дополнительно:</p>
<ol type="1">
<li class="fragment"><a href="../ca1d/ca1d.htm">Эмулятор одномерного
клеточного автомата</a> <a href="https://github.com/CodeDrome/cellular-automata-1d-javascript">(источник)</a></li>
<li class="fragment">Эмулятор двумерного клеточного автомата: <a href="http://golly.sourceforge.net/" class="uri">http://golly.sourceforge.net/</a></li>
<li class="fragment">Эмулятор игры Тетрис в игре "Жизнь": <a href="https://codegolf.stackexchange.com/q/11880" class="uri">https://codegolf.stackexchange.com/q/11880</a></li>
<li class="fragment">Универсальная машина Тьюринга в игре "Жизнь": <a href="http://rendell-attic.org/gol/utm/index.htm" class="uri">http://rendell-attic.org/gol/utm/index.htm</a></li>
</ol>
</section><div><a class="slider-prev" href="#типы-поведения-автоматов"></a><a class="slider-next" href="#rule-110"></a></div>
<section id="rule-110" class="slide level1">
<h1>Rule 110</h1>
<p>Из Wolfram MathWorld: <a href="http://mathworld.wolfram.com/Rule110.html" class="uri">http://mathworld.wolfram.com/Rule110.html</a></p>
<p><img data-src="images/ElementaryCARule110_1000.gif" src="images/ElementaryCARule110_1000.gif"></p>
<p><a href="https://wpmedia.wolfram.com/uploads/sites/13/2018/02/15-1-1.pdf">Эмуляция
машины Тьюринга правилом 110</a></p>
</section><div><a class="slider-prev" href="#тьюринг-эквивалентные-клеточные-автоматы"></a><a class="slider-next" href="#эмуляция-машины-тьюринга-правилом-110"></a></div>
<section id="эмуляция-машины-тьюринга-правилом-110" class="slide level1">
<h1>Эмуляция машины Тьюринга правилом 110</h1>
<ol type="1">
<li class="fragment"><p>Машины Тьюринга можно эмулировать tag-системой
Поста. Тэг-система Поста считывает по 2 (в общем случае — n) символов с
начала ленты с данными, определяет на основе первого символа новую
последовательность символов («дополнение») и дописывает её в конец
ленты.</p></li>
<li class="fragment"><p>Тэг-систему можно эмулировать циклической
тэг-системой: на ленте могут быть только символы Y, N; программа
задаётся зацикленной последовательностью дополнений; если считан символ
Y, текущее дополнение дописывается в конец и машина переходит к
следующему дополнению, если N — машина просто переходит к следующему
дополнению.</p></li>
<li class="fragment"><p>Циклическая тэг-система эмулируется системами
глайдеров — движущихся (по прямой) точек разного типа (тип задаёт
направление движения), при столкновении которых из точки могут начать
движение глайдеры другого типа.</p></li>
<li class="fragment"><p>Система глайдеров эмулируется правилом
110.</p></li>
</ol>
</section><div><a class="slider-prev" href="#rule-110"></a><a class="slider-next" href="#понятие-тьюринг-полноты-в-компьютерных-языках-1"></a></div>
<section id="понятие-тьюринг-полноты-в-компьютерных-языках-1" class="slide level1">
<h1>Понятие «Тьюринг-полноты» в компьютерных языках</h1>
</section><div><a class="slider-prev" href="#эмуляция-машины-тьюринга-правилом-110"></a><a class="slider-next" href="#машины-с-регистрами"></a></div>
<section id="машины-с-регистрами" class="slide level1">
<h1>Машины с регистрами</h1>
<p>Машина с регистрами включает:</p>
<ol type="1">
<li class="fragment">Неограниченное (как правило, конечное) количество
именованных регистров, каждый из которых может содержать одно
неотрицательное число неограниченного размера.</li>
<li class="fragment">Набор меток.</li>
<li class="fragment">Ограниченный набор инструкций, который может
включать:
<ol type="1">
<li class="fragment">Арифметические инструкции (Increment(r),
Decrement(r), Clear-to-zero(r), Load-constant(r, k), Add, Subtract,
...)</li>
<li class="fragment">Управляющие инструкции (Copy(r<sub>1</sub>,
r<sub>2</sub>), LoadAccumulator(r), StoreAccumulator(r))</li>
<li class="fragment"><strong>Условный переход</strong> (обязательно; как
правило, по заданному регистру): Jump-if-zero, Jump-if-not-zero,
Jump-if-equal, ...</li>
<li class="fragment">Операции непрямой адресации (Load-from-address(r),
Store-by-address(r))</li>
<li class="fragment">Ввод-вывод</li>
</ol></li>
<li class="fragment">Регистр состояний — содержит текущую инструкцию и
её адрес в программе.</li>
<li class="fragment">Список инструкций с метками (как правило,
последовательный).</li>
</ol>
<p>Классы: машины со счётчиками, машины с указателями, машины с памятью
с произвольным доступом, машины с памятью с произвольным доступом с
программой в регистрах (архитектура фон Неймана)</p>
</section><div><a class="slider-prev" href="#понятие-тьюринг-полноты-в-компьютерных-языках-1"></a><a class="slider-next" href="#аппаратные-реализации"></a></div>
<section id="аппаратные-реализации" class="slide level1">
<h1>«Аппаратные» реализации</h1>
<ol type="1">
<li class="fragment"><p>URISC (Ultimate Restricted Instruction Set
Computer) — машина с одной инструкцией. Для того, чтобы иметь
возможность эмулировать машину Тьюринга, память должна быть бесконечной,
а адреса и ячейки — произвольными целыми числами (возможно,
неотрицательными)</p>
<ul>
<li class="fragment"><code>subleq a, b, c</code> — посчитать
<code>M[b] - M[a]</code>, записать в <code>M[b]</code> и, если
<code>b ≤ 0</code> перейти на адрес <code>c</code>. В памяти хранятся
тройки <code>a, b, c</code></li>
<li class="fragment"><code>dln a, b</code> — уменьшить на 1 значение
<code>M[a]</code>; если получился <code>0</code>, перейти по адресу
<code>b</code></li>
</ul></li>
<li class="fragment"><p>Механизм защиты памяти в x86-процессорах
допускает реализацию <code>subleq</code> с помощью вложенных исключений
page fault</p></li>
<li class="fragment"><p>Magic: The Gathering (и другие примеры на
странице <a href="http://beza1e1.tuxen.de/articles/accidentally_turing_complete.html">Accidentally
Turing-complete</a>)</p></li>
</ol>
</section><div><a class="slider-prev" href="#машины-с-регистрами"></a><a class="slider-next" href="#μ-рекурсивные-функции-клини-1"></a></div>
<section id="μ-рекурсивные-функции-клини-1" class="slide level1">
<h1>μ-рекурсивные функции Клини</h1>
<p>Частично-рекурсивные функции на натуральных числах.</p>
<h2 id="функции">Функции</h2>
<ol type="1">
<li class="fragment">k-арные константные функции
K<sup>k</sup><sub>n</sub>.</li>
</ol>
<p>K<sup>k</sup><sub>n</sub>(x<sub>1</sub>, …, x<sub>k</sub>) = n</p>
<ol start="2" type="1">
<li class="fragment">1-арная функция увеличения на 1</li>
</ol>
<p>S(x) = x + 1</p>
<ol start="3" type="1">
<li class="fragment">Функции проекции P<sup>k</sup><sub>i</sub>
P<sup>k</sup><sub>i</sub>(x<sub>1</sub>, …, x<sub>k</sub>) =
x<sub>i</sub></li>
</ol>
<h2 id="операторы">Операторы</h2>
<ol type="1">
<li class="fragment">Оператор подстановки ∘ для m-арной функции h и m
k-арных функций g<sub>i</sub> определяет k-арную функцию</li>
</ol>
<p>h ∘ (g<sub>1</sub>, …, g<sub>m</sub>) = f(x<sub>1</sub>, …,
x<sub>k</sub>)</p>
<p>f = h(g<sub>1</sub>(x<sub>1</sub>, …, x<sub>k</sub>), …,
g<sub>m</sub>(x<sub>1</sub>, …, x<sub>k</sub>))</p>
</section><div><a class="slider-prev" href="#аппаратные-реализации"></a><a class="slider-next" href="#μ-рекурсивные-функции-клини-2"></a></div>
<section id="μ-рекурсивные-функции-клини-2" class="slide level1">
<h1>μ-рекурсивные функции Клини</h1>
<h2 id="операторы-1">Операторы</h2>
<ol start="2" type="1">
<li class="fragment">Оператор примитивной рекурсии («цикл») <span class="math inline"><em>ρ</em>(<em>g</em>,<em>h</em>)</span> по k-арной
функции <span class="math inline"><em>g</em></span> (база индукции) и
k+2-арной функции h (шаг индукции) определяет k-арную функцию <span class="math inline"><em>f</em></span>:</li>
</ol>
<p>f(0, x<sub>1</sub>, …, x<sub>k</sub>) = g(x<sub>1</sub>, …,
x<sub>k</sub>)</p>
<p>f(y+1, x<sub>1</sub>, …, x<sub>k</sub>) = h(y, f(y, x<sub>1</sub>, …,
x<sub>k</sub>), x<sub>1</sub>, …, x<sub>k</sub>)</p>
<p>Первые два аргумента h — число итераций и результат предыдущей
итерации.</p>
<ol start="3" type="1">
<li class="fragment">Оператор минимизации <span class="math inline"><em>μ</em></span> для k+1-арной полной функции f
возвращает k-арную частичную функцию, которая находит минимальное
значение первого аргумента <span class="math inline"><em>z</em></span>,
при котором f(z, x<sub>1</sub>, …, x<sub>k</sub>) = 0:</li>
</ol>
<p>μ(f)(x<sub>1</sub>, …, x<sub>k</sub>) = z : f(z, x<sub>1</sub>, …,
x<sub>k</sub>) = 0; f(i &lt; z, x<sub>1</sub>, …, x<sub>k</sub>) &gt;
0</p>
<p><a href="http://people.irisa.fr/Francois.Schwarzentruber/recursive_functions_to_turing_machines/">Компилятор
подмножества😕 рекурсивных функций в машину Тьюринга</a></p>
</section><div><a class="slider-prev" href="#μ-рекурсивные-функции-клини-1"></a><a class="slider-next" href="#операторная-схема-программы"></a></div>
<section id="операторная-схема-программы" class="slide level1">
<h1>Операторная схема программы</h1>
<p>Классический советский подход к теории программирования, предложенный
А.А. Ляпуновым в первом курсе «Принципы программирования», который он
читал в 1952/53 году на кафедре вычислительной математики.</p>
<p>В более позднем определении А.П. Ершова:</p>
<p>Задано конечное множество <em>операторов</em> F = { F<sub>1</sub>, …,
F<sub>n</sub>}. Входы и выходы описываются в терминах <em>полюсов</em>
операторов P = A ∪ R — объединение непересекающихся множеств
<em>аргументов</em> A = {a<sub>1</sub>, …, a<sub>p</sub>} и
<em>результатов</em> R = { r<sub>1</sub>, …, r<sub>q</sub> }.
<em>Распределение полюсов</em> — отображение V : P → F.</p>
<p><em>Граф переходов</em> — ориентированный граф C = (F, J), где J —
бинарное отношение, задающее для оператора его преемников по передаче
управления. Компоненты связности графа переходов — отдельные программы в
программном комплексе.</p>
<p><em>Скелет</em> программы — набор перечисленных множеств S = (F, C,
A, R, V).</p>
<p><em>Память</em> описывается множеством X = { x<sub>1</sub>, …,
x<sub>m</sub> } и распределяется среди полюсов отображением L : P →
X.</p>
<p>Операторная схема программы — набор G = (S, X, L).</p>
</section><div><a class="slider-prev" href="#μ-рекурсивные-функции-клини-2"></a><a class="slider-next" href="#задача-экономии-памяти"></a></div>
<section id="задача-экономии-памяти" class="slide level1">
<h1>Задача экономии памяти</h1>
<p>А.П. Ершов в книге (ссылка ниже) рассматривает задачу экономии
памяти: каким образом можно использовать минимальное множество памяти X,
сохраняя семантику программы?</p>
<p>Постановка задачи: по заданной схеме программы с <em>распределением
памяти</em> L построить новое распределение памяти L', использующее, по
возможности, память меньшего объёма.</p>
<p>А. П. Ершов. Введение в теоретическое программирование: беседы о
методе. М.: Наука, 1977. 288 С.</p>
</section><div><a class="slider-prev" href="#операторная-схема-программы"></a><a class="slider-next" href="#задача-экономии-памяти-1"></a></div>
<section id="задача-экономии-памяти-1" class="slide level1">
<h1>Задача экономии памяти</h1>
<p><em>Информационный граф</em> I = (P, M) — двудольный граф M ⊂ R×A,
который сопоставляет результаты оператора с аргументами его преемников.
<em>Маршрут информационной связи</em> — путь в информационном графе,
задаётся первым результатом и последним аргументом.</p>
<p>Компоненты связности информационного графа называются <em>областями
действия</em>.</p>
<p>Области действия <em>несовместимы</em> тогда и только тогда, когда в
каждой из них найдутся результаты r и r', соответственно, такие,
что:</p>
<ul>
<li class="fragment">V(r) = V(r') или</li>
<li class="fragment">V(r) — внутренний оператор маршрута информационной
связи (r', a')</li>
<li class="fragment">V(r') — внутренний оператор маршрута информационной
связи (r, a)</li>
</ul>
<p>Задача экономии памяти решается выделением несовместимых областей
действия раскраской графа и объединением совместимых областей
действия.</p>
</section><div><a class="slider-prev" href="#задача-экономии-памяти"></a><a class="slider-next" href="#схема-янова"></a></div>
<section id="схема-янова" class="slide level1">
<h1>Схема Янова</h1>
<p>Модификация операторной схемы программ. Область приложения —
исследование способов задания условий в программе и эквивалентных
преобразований программ с условиями.</p>
<p>Не рассматривается понятие памяти и распределения памяти. Все
операторы одноместны, принимают на вход исходное состояние памяти и
возвращают полностью изменённое состояние.</p>
<p>Вводятся счётные множества <em>предикатных символов</em>
<strong>P</strong> = { p<sub>1</sub>, p<sub>2</sub>, … } и
<em>операторных символов</em> <strong>A</strong> = { A<sub>1</sub>,
A<sub>2</sub>, … }.</p>
<p><em>Оператор</em> A = A(P) — пара из операторного символа A и
некоторого (возможно, пустого) множества предикатных символов P, которое
называется <em>сдвигом</em> оператора A.</p>
</section><div><a class="slider-prev" href="#задача-экономии-памяти-1"></a><a class="slider-next" href="#схема-янова-1"></a></div>
<section id="схема-янова-1" class="slide level1">
<h1>Схема Янова</h1>
<p><em>Граф переходов</em> — ориентированный граф, множество вершин
которого состоит из неотрицательного числа <em>преобразователей</em>,
<em>распознавателей</em> и одного <em>останова</em>. Из преобразователя
выходит в точности одна дуга, из распознавателя — две различные
(<em>плюс-стрелка</em> и <em>минус-стрелка</em>). Выделяется одна
<em>входная</em> вершина графа и помечается <em>входной
стрелкой</em>.</p>
<p><em>Преобразователи</em> помечены операторными символами,
<em>распознаватели</em> помечены логическими формулами над
<em>предикатными</em> символами.</p>
<p><em>Схема Янова</em> G(p<sub>1</sub>, …, p<sub>k</sub>)</p>
</section><div><a class="slider-prev" href="#схема-янова"></a><a class="slider-next" href="#схема-янова-2"></a></div>
<section id="схема-янова-2" class="slide level1">
<h1>Схема Янова</h1>
<p><img data-src="images/Yanov_schemata.gif" src="images/Yanov_schemata.gif"></p>
</section><div><a class="slider-prev" href="#схема-янова-1"></a><a class="slider-next" href="#семантика-схемы-янова"></a></div>
<section id="семантика-схемы-янова" class="slide level1">
<h1>Семантика схемы Янова</h1>
<p>Для того, чтобы схема задавала программу, необходимо дать
<em>интерпретацию</em> операторным и предикатным символам, и описать
алгоритм выполнения интерпретированной схемы.</p>
<p>Дано некоторое множество <em>состояний памяти</em> D. Предикатные
символы p<sub>i</sub> соответствуют предикатам π<sub>i</sub> : D → {
<strong>f</strong>, <strong>t</strong> }. Сами p<sub>i</sub> в программе
назовём <em>предикатными переменными</em>.</p>
<p>Операторным символам A<sub>j</sub> сопоставляются (возможно,
частичные) функции φ<sub>j</sub> : D → D</p>
</section><div><a class="slider-prev" href="#схема-янова-2"></a><a class="slider-next" href="#выполнение-схемы-янова"></a></div>
<section id="выполнение-схемы-янова" class="slide level1">
<h1>Выполнение схемы Янова</h1>
<p><strong>Начальный шаг.</strong> Берём произвольное d ∈ D в качестве
исходного состояния памти и присваиваем значения всем предикатным
переменным p<sub>i</sub> ≡ π<sub>i</sub>(d). Передаём управление на
входную вершину графа переходов.</p>
<p><strong>Шаг выполнения.</strong> Пусть d — текущее состояние памяти,
Δ = (σ<sub>1</sub>, …, σ<sub>k</sub>) — текущие значения предикатных
переменных, S — текущая вершина графа переходов.</p>
<ol type="1">
<li class="fragment">Если S — останов, то выполнение завершается, и d
является результатом выполнения схемы в данной интерпретации.</li>
<li class="fragment">Если S — распознаватель с условием F(p<sub>1</sub>,
…, p<sub>k</sub>). Вычисляем σ = F(Δ) и передаём управление по
плюс-стрелке, если σ=<strong>t</strong> и по минус-стрелке, если
σ=<strong>f</strong>.</li>
<li class="fragment">Если S — преобразователь
A<sub>j</sub>(P<sub>j</sub>), вычисляем новое состояние памяти d' =
φ<sub>j</sub>(d) и значения предикатных переменных в сдвиге
P<sub>j</sub> : p<sub>i</sub> ≡ π<sub>i</sub>(d'). Управление передаётся
на следующую вершину графа.</li>
</ol>
<p>Таким образом, получена частичная функция d =
<strong>F</strong><sub>G,I</sub>(d<sub>0</sub>).</p>
</section><div><a class="slider-prev" href="#семантика-схемы-янова"></a><a class="slider-next" href="#эквивалентность-схем"></a></div>
<section id="эквивалентность-схем" class="slide level1">
<h1>Эквивалентность схем</h1>
<p>Схемы G<sub>1</sub> и G<sub>2</sub> <em>сравнимы</em>, если они
заданы над одним и тем же множеством предикатных символов, а также у
одинаковых операторов совпадают сдвиги.</p>
<p>Две сравнимые схемы <em>эквивалентны</em> в некоторой совместной
интерпретации I, если F<sub>G1,I</sub>(d) = F<sub>G2,I</sub>(d).</p>
<p>Две сравнимые схемы <em>функционально эквивалентны</em>, если они
эквивалентны в любой совместной интерпретации.</p>
<p><em>Операционная история</em> (след) интерпретированной схемы Янова
H<sub>G,I</sub>(d) — полная последовательность выполняемых операторов и
наборов значений функциональных переменных. Для исключения циклов
вершины графа помечаются наборами значений предикатных переменных. Если
при выполнении мы попали в вершину, помеченную таким же набором
значений, что и текущий набор Δ, считаем, что мы попали в бесконечный
цикл.</p>
<p>Две сравнимые схемы <em>операционно эквивалентны</em>, если они
одинаково работают в любой совместной интерпретации, т.е.
H<sub>G1,I</sub>(d) = H<sub>G2,I</sub>(d).</p>
<p><strong>Теорема.</strong> Функциональная эквивалентность равносильна
операционной эквивалентности.</p>
</section><div><a class="slider-prev" href="#выполнение-схемы-янова"></a><a class="slider-next" href="#эквивалентность-схем-1"></a></div>
<section id="эквивалентность-схем-1" class="slide level1">
<h1>Эквивалентность схем</h1>
<p><em>Конфигурации</em> схемы k ∈ K(G) строятся аналогично операционным
историям, но без заданной интерпретации индуктивно:</p>
<p><strong>Начальный шаг.</strong> Выберем произвольный набор исходных
значений предикатных переменных Δ. <strong>Очередной шаг.</strong>
Текущий набор Δ, текущая вершина S. Уже обработанные вершины
помечены.</p>
<ol type="1">
<li class="fragment">Если S — помеченный распознаватель, то мы попали в
пустой цикл и конфигурация не может быть построена.</li>
<li class="fragment">Если S — непомеченный распознаватель с условием F,
помечаем его, вычисляем F(Δ) и переходим к вершине-преемнику.</li>
<li class="fragment">Если S — останов, построение конфигурации
завершено.</li>
<li class="fragment">Если S — оператор, то записываем A<sub>i</sub> в
конфигурацию, и в качестве нового значения Δ' помещаем произвольный
набор, образующий с набором Δ допустимую пару для оператора
A<sub>i</sub>.</li>
</ol>
<p>Две сравнимые схемы <em>формально эквивалентны</em>, если их
множества их конфигураций совпадают.</p>
<p><strong>Теорема.</strong> Функциональная эквивалентность равносильна
формальной эквивалентности.</p>
</section><div><a class="slider-prev" href="#эквивалентность-схем"></a><a class="slider-next" href="#эквивалентные-преобразования"></a></div>
<section id="эквивалентные-преобразования" class="slide level1">
<h1>Эквивалентные преобразования</h1>
<p><strong>Теорема.</strong> Для любых двух эквивалентных схем Янова
можно построить последовательность эквивалентных преобразований, которые
приводят их к общему виду.</p>
<p><strong>Теорема.</strong> Задача эквивалентности двух сравнимых схем
Янова разрешима.</p>
<p>Подловченко Р. И. К вопросу об эквивалентных преобразованиях
алгоритмов и программ // Математические вопросы кибернетики. Вып. 9. —
М.: Физматлит, 2000. — С. 25–36. URL: <a href="http://library.keldysh.ru/mvk.asp?id=2000-25" class="uri">http://library.keldysh.ru/mvk.asp?id=2000-25</a></p>
</section><div><a class="slider-prev" href="#эквивалентность-схем-1"></a><a class="slider-next" href="#задачи"></a></div>
<section id="задачи" class="slide level1">
<h1>Задачи</h1>
<dl>
<dt class="fragment"><strong>Задача 3.1*</strong></dt>
<dd class="fragment">
реализуйте интерпретатор <span class="math inline"><em>μ</em></span>-рекурсивных функций Клини с
возможностью пошагового выполнения.
</dd>
<dt class="fragment"><strong>Задача 3.2**</strong></dt>
<dd class="fragment">
реализуйте проверку числа на простоту в терминах μ-рекурсивных функций
Клини.
</dd>
<dt class="fragment"><strong>Задача 3.3*</strong></dt>
<dd class="fragment">
реализуйте интерпретатор произвольных клеточных автоматов с
"квадратными" клетками, в качестве примера покажите работоспособную
реализацию игры "жизнь".
</dd>
<dt class="fragment"><strong>Задача 3.4***</strong></dt>
<dd class="fragment">
предложите возможные способы задания системы типов, не допускающей
задание незавершимых функций, для клеточных автоматов или для
μ-рекурсивных функций Клини (текст, от 5 страниц A4, шрифт 14пт,
междустрочный интервал 1.5).
</dd>
<dt class="fragment"><strong>Задача 3.5***</strong></dt>
<dd class="fragment">
опишите в терминах схем Янова один из алгоритмов сортировки списка и
докажите его корректность.
</dd>
<dt class="fragment"><strong>Задача 3.6**</strong></dt>
<dd class="fragment">
верно ли, что "классический" глайдер для двумерного клеточного автомата
с «обычной» окрестностью работает только для правила Game of Life?
Аналогичный вопрос про «линейку» из трёх заполненных клеток.
</dd>
</dl>
</section><div><a class="slider-prev" href="#эквивалентные-преобразования"></a><a class="slider-next"></a></div>

<!-- start page -->
   <div id="slider">
       <a href="#математические-модели-вычислений" class="slider-start">PLAY</a>
   </div>

   <!-- progressbar container -->
   <div class="slider-progress"></div>
   </article>
  </div>

  
  <script type="text/javascript">
  function handleKeydown(e) {
     if (e.altKey || e.ctrlKey || e.metaKey || e.shiftKey) { return; }
     switch (e.keyCode) {
       case 35: // End
          var arr = document.querySelectorAll("a.slider-next:link");
          var a = arr[arr.length - 1];
          if (a && a.href) {
            window.location = a.href;
          }
          break;
       case 36: // Home
          var a = document.querySelector("a.slider-start");
          if (a && a.href) {
            window.location = a.href;
          }
          break;
       case 33: // Page Up
       case 37: // left arrow
         var a = document.querySelector("section:target ~ div a.slider-prev");
         if (a && a.href) {
           window.location = a.href;
         }
         break;
       case 34: // Page Down
       case 39: // right arrow
         var a = document.querySelector("section:target ~ div a.slider-next");
         if (a && a.href) {
           window.location = a.href;
         }
         break;
     }
  }
  document.addEventListener("keydown", handleKeydown);
  document.getElementById("flat-view").addEventListener("click", function(e) {
    document.getElementById("main").classList.toggle('slider');
    if (document.getElementById("main").classList.contains('slider')) {
      document.getElementById("container").style="width: 640px;height: 400px;";
      document.addEventListener("keydown", handleKeydown);
    } else {
      document.getElementById("container").style="";
      document.removeEventListener("keydown", handleKeydown);
    }
  })
  </script>
  

</body></html>

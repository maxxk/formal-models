<!DOCTYPE html><html><head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title>02-Entscheidungsproblem</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="slider.css">
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
  <div style="width: 640px;height: 400px;">
  <input id="slider-max" type="checkbox" checked="">
   <article class="slider slider-indicator">
   <a id="slider-default"></a>
   <label for="slider-max" title="Maximize"></label>


<section id="математические-модели-вычислений" class="slide level1">
<h1>Математические модели вычислений</h1>
<h2 id="entscheidungsproblem-проблема-разрешения-машина-тьюринга-конечные-автоматы-и-формальные-языки">Entscheidungsproblem (проблема разрешения). Машина Тьюринга. Конечные автоматы и формальные языки.</h2>
<p><strong>Максим Александрович Кривчиков</strong>, к.ф.-м.н., н.с. МГУ имени М.&nbsp;В.&nbsp;Ломоносова</p>
<p><a href="mailto:maxim.krivchikov@gmail.com" class="email">maxim.krivchikov@gmail.com</a></p>
<p>Материалы курса: <a href="https://maxxk.github.io/formal-models/" class="uri">https://maxxk.github.io/formal-models/</a></p>
</section><div><a class="slider-prev"></a><a class="slider-next" href="#формальная-верификация--формализация-математики"></a></div>
<section id="формальная-верификация--формализация-математики" class="slide level1">
<h1>Формальная верификация → формализация математики</h1>
<p>Для проведения формальной верификации функциональных свойств программ необходимо получить математическое описание таких свойств.</p>
<p>Программы объёмны и сложны по своей структуре, поэтому можно предположить, что доказательства их свойств тоже будут не проще.</p>
<p>⇒ Необходимо получить описание программ, их функциональных свойств и доказательств соответствия в форме, которая допускает автоматизированную проверку.</p>
</section><div><a class="slider-prev" href="#математические-модели-вычислений"></a><a class="slider-next" href="#кризис-оснований-математики"></a></div>
<section id="кризис-оснований-математики" class="slide level1">
<h1>Кризис оснований математики</h1>
<p><a href="http://personal.us.es/josef/pcmCrisis.pdf" class="uri">http://personal.us.es/josef/pcmCrisis.pdf</a> (использовано в презентации)</p>
<p><a href="https://en.wikipedia.org/wiki/Foundations_of_mathematics#Foundational_crisis" class="uri">https://en.wikipedia.org/wiki/Foundations_of_mathematics#Foundational_crisis</a></p>
<p>К концу XIX века имела место дискуссия о новых подходах в математике, разработанных, в частности, Гауссом, Дирихле и используемых Дедекиндом. Основные положения этих методов:</p>
<ol type="1">
<li class="fragment">Допускается использовать понятие «произвольной» функции.</li>
<li class="fragment">Допускается использовать бесконечные множества (а также рассуждать о континууме и т.д.).</li>
<li class="fragment">«Размышления предпочтительнее вычислений» (Дирихле), нужно отдавать предпочтение изучению аксиоматически описываемой структуры объектов.</li>
<li class="fragment">Допускаются теоремы существования, не описывающие способ построения объекта.</li>
</ol>
</section><div><a class="slider-prev" href="#формальная-верификация--формализация-математики"></a><a class="slider-next" href="#парадоксы-теории-множеств"></a></div>
<section id="парадоксы-теории-множеств" class="slide level1">
<h1>Парадоксы теории множеств</h1>
<p>В начале XX века был представлен ряд парадоксов наивной теории множеств, связанный с широко обсуждаемыми с конца XIX века метаматематическими концепциями — в первую очередь связанных с допустимостью тех или иных определений.</p>
<p>Парадокс Б. Рассела (Цермело – Рассела, 1901-02) («парадокс брадобрея»): Брадобрей бреет в точности тех горожан, которые не бреются сами. Кто бреет брадобрея?</p>
<p>R = { x | x ∈ x } ⟹ ( R ∈ R ⇔ R ∉ R )</p>
<p>Ошибка — возможность определения «множества всех множеств».</p>
</section><div><a class="slider-prev" href="#кризис-оснований-математики"></a><a class="slider-next" href="#парадоксы-теории-множеств-1"></a></div>
<section id="парадоксы-теории-множеств-1" class="slide level1">
<h1>Парадоксы теории множеств</h1>
<p>Парадокс Бурали-Форти: пусть x — ординал, а ∪x — верхняя грань x. Для Q — множества всех ординалов, ∪Q+1 — ординал, который не лежит в Q.</p>
<p>Ошибка — возможность определения множества элементов, обладающих произвольным свойством.</p>
<p>Ординал — транзитивное множество, которое является полным порядком по отношению включения</p>
<p>⇒ математика в опасности</p>
</section><div><a class="slider-prev" href="#парадоксы-теории-множеств"></a><a class="slider-next" href="#предикативность"></a></div>
<section id="предикативность" class="slide level1">
<h1>Предикативность</h1>
<p>Пуанкаре (1903). <strong>Импредикативное</strong> определение — определение, которое ссылается само на себя. С позиций теории множеств определение импредикативно, если оно использует (в нём упоминается, или в нём используется квантификация по) само определяемое множество, или другое множество, которое содержит определяемое.</p>
<p>Использование только предикативных определений, таким образом, должно прервать «порочный круг».</p>
<p><strong>Пример.</strong> Натуральные числа по Дедекинду. ℕ есть пересечение всех множеств (= минимальное множество), которые содержат 1 и замкнуты под инъективной функцией σ, такой, что 1 ∉ σ(ℕ).</p>
</section><div><a class="slider-prev" href="#парадоксы-теории-множеств-1"></a><a class="slider-next" href="#теория-типов-рассел-уайтхед"></a></div>
<section id="теория-типов-рассел-уайтхед" class="slide level1">
<h1>Теория типов (Рассел, Уайтхед)</h1>
<p>(B. Russel, A.N. Whitehead. Principia Mathematica. Cambridge University Press, 1910)</p>
<p>Парадоксы можно исключить, если рассматривать только множества с единообразными элементами (например, элементы множества { {a}, {b} } единообразны, а элементы множества { {a}, b } — нет).</p>
</section><div><a class="slider-prev" href="#предикативность"></a><a class="slider-next" href="#конструктивизм-и-интуиционизм"></a></div>
<section id="конструктивизм-и-интуиционизм" class="slide level1">
<h1>Конструктивизм и интуиционизм</h1>
<p>Конструктивизм (общий подход) — доказательство существования объекта обязательно должно строить объект. Доказательства существования от противного (пусть объекта не существует, тогда приходим к противоречию) не допускаются.</p>
<p>Интуиционизм (Брауэр) — исходное направление конструктивизма, в котором утверждается, что математика субъективна (является результатом конструктивной мыслительной деятельности), а следовательно математическое исследование должно заключаться не в доказательстве «универсально истинных» теорем, а в поиске математических (умственных) конструкций, органично соединяющих в себе построение и его обоснование.</p>
</section><div><a class="slider-prev" href="#теория-типов-рассел-уайтхед"></a><a class="slider-next" href="#конструктивизм-и-интуиционизм-1"></a></div>
<section id="конструктивизм-и-интуиционизм-1" class="slide level1">
<h1>Конструктивизм и интуиционизм</h1>
<p>Примеры:</p>
<ul>
<li class="fragment">диагональный процесс Кантора (доказательство несчётности множества действительных чисел ℝ) конструктивен</li>
<li class="fragment">классическая формулировка действительного анализа (теории меры Лебега) неконструктивна, но может быть сделана конструктивной если ограничиться рассмотрением функций в форме поточечных пределов непрерывных функций (нестрого).</li>
</ul>
</section><div><a class="slider-prev" href="#конструктивизм-и-интуиционизм"></a><a class="slider-next" href="#закон-исключённого-третьего"></a></div>
<section id="закон-исключённого-третьего" class="slide level1">
<h1>Закон исключённого третьего</h1>
<p>p ∨ ¬p → true для всех p</p>
<p>Брауэр: логические принципы построены на основе нашего опыта работы с конечными множествами, их нельзя распространять на бесконечные. Связка «или» (a ∨ b) может употребляться только после того, как одна из альтернатив была доказана.</p>
<p>Конструктивизм: закон исключённого третьего с точки зрения конструктивизма даёт аппарат разрешения любых утверждений, а такой аппарат (забегая вперёд) построить нельзя.</p>
</section><div><a class="slider-prev" href="#конструктивизм-и-интуиционизм-1"></a><a class="slider-next" href="#аксиома-выбора"></a></div>
<section id="аксиома-выбора" class="slide level1 small">
<h1>Аксиома выбора</h1>
<p>Классическая формулировка: для всякого семейства (S<sub>i</sub>)<sub>i∈I</sub> непустых множеств существует <em>функция выбора</em> <em>f</em>, которая каждому множеству семейства сопоставляет один из элементов этого множества. Для бесконечных семейста независима от утверждений теории множеств. В некоторых конструктивных теориях допускаются более слабые формулировки аксиомы выбора, из которых не следует закон исключённого третьего.<br>
<img data-src="images/Axiom_of_choice.svg" src="images/Axiom_of_choice.svg"></p>
</section><div><a class="slider-prev" href="#закон-исключённого-третьего"></a><a class="slider-next" href="#формализм"></a></div>
<section id="формализм" class="slide level1">
<h1>Формализм</h1>
<p>— все математические утверждения записываются в виде формул (строк символов), которые переписываются по конечному набору правил, про которые известно, что они не дадут парадоксов.</p>
<p>Д. Гильберт предложил такой подход для того, чтобы «раз и навсегда очистить мир от всех скептических сомнений» в части справедливости классических теорий математики.</p>
</section><div><a class="slider-prev" href="#аксиома-выбора"></a><a class="slider-next" href="#формализм-1"></a></div>
<section id="формализм-1" class="slide level1">
<h1>Формализм</h1>
<ol type="1">
<li class="fragment">Сформулировать строгие синтаксические аксиомы и правила вывода (переписывания).</li>
<li class="fragment">Доказать 3 простых свойства, которые показывают, что аксиомы «хорошие» (программа Гильберта):
<ol type="1">
<li class="fragment">Полнота (мы можем переписыванием получить из аксиом все истинные утверждения математики)</li>
<li class="fragment">Непротиворечивость (мы не можем получить переписыванием из аксиом ложное утверждение)</li>
<li class="fragment">Разрешимость (руководствуясь простым набором правил можно для любой формулы получить, выводима она или нет).</li>
</ol></li>
<li class="fragment">Представить основные теоремы анализа в терминах этой системы</li>
</ol>
</section><div><a class="slider-prev" href="#формализм"></a><a class="slider-next" href="#проблема-разрешения-entscheidungsproblem"></a></div>
<section id="проблема-разрешения-entscheidungsproblem" class="slide level1">
<h1>Проблема разрешения (Entscheidungsproblem)</h1>
<p>В более широком смысле <em>задача разрешения</em> некоторого, возможно параметризованного, утверждения — это задача построения эффективного алгоритма, который принимает на вход параметр и всегда даёт ответ: значение <code>0</code>, если утверждение неверно для параметра, или значение <code>1</code>, если утверждение верно для параметра.</p>
<p>В узком смысле <em>проблема разрешения</em> — это вопрос, является ли разрешимой истинность формул логики первого порядка, которая предполагалась Гильбертом в качестве основного кандидата программы.</p>
<p>Как строго определить «эффективный алгоритм»?</p>
</section><div><a class="slider-prev" href="#формализм-1"></a><a class="slider-next" href="#машина-тьюринга"></a></div>
<section id="машина-тьюринга" class="slide level1 small">
<h1>Машина Тьюринга</h1>
<ul>
<li class="fragment">Бесконечная лента, разделённая на ячейки, в каждой из которых находится символ из алфавита Γ, один из символов «пустой»</li>
<li class="fragment">Состояние машины q ∈ Q</li>
<li class="fragment">Читающая и пишущая головка над лентой на каждом шаге считывает символ, обрабатывает его, записывает новый символ в ячейку и сдвигается влево, вправо или останавливается</li>
<li class="fragment">Инструкции вида: если в состоянии q считан символ a, то перейти в состояние r, записать символ b и переместить головку вправо/влево/остановить вычисления <img data-src="images/Universal_Turing_machine.svg" src="images/Universal_Turing_machine.svg"></li>
</ul>
</section><div><a class="slider-prev" href="#проблема-разрешения-entscheidungsproblem"></a><a class="slider-next" href="#машина-тьюринга-формально"></a></div>
<section id="машина-тьюринга-формально" class="slide level1">
<h1>Машина Тьюринга формально</h1>
<p>Семёрка:</p>
<ol type="1">
<li class="fragment">Q — конечное, непустое множество состояний</li>
<li class="fragment">Γ — конечный непустой алфавит ленты</li>
<li class="fragment"><code>_</code> ∈ Γ — пустой символ, только он может быть на ленте бесконечное число раз</li>
<li class="fragment">Σ ⊆ Γ \ { <code>_</code> } — набор входных символов (оставшиеся Γ \ { <code>_</code> } \ Σ — служебные символы)</li>
<li class="fragment">F ⊆ Q — множество конечных состояний (часто состоит из одного состояния <code>HALT</code>)</li>
<li class="fragment">δ : (Q \ F) × Γ → Q × Γ × { L, R } — частичная функция перехода; если попадается пара (состояние, текущий символ), на которой δ не определена, машина останавливается.</li>
<li class="fragment">q<sub>0</sub> ∈ Q — начальное состояние</li>
</ol>
</section><div><a class="slider-prev" href="#машина-тьюринга"></a><a class="slider-next" href="#интерактивная-демонстрация-машины-тьюринга"></a></div>
<section id="интерактивная-демонстрация-машины-тьюринга" class="slide level1">
<h1>Интерактивная демонстрация машины Тьюринга</h1>
<p>Механическая модель машины Тьюринга: <a href="https://www.youtube.com/watch?v=WJ-ODmFjmrU" class="uri">https://www.youtube.com/watch?v=WJ-ODmFjmrU</a></p>
<p>Модель машины Тьюринга из LEGO: <a href="https://www.youtube.com/watch?v=FTSAiF9AHN4" class="uri">https://www.youtube.com/watch?v=FTSAiF9AHN4</a></p>
<p>Интерактивная реализация в браузере: <a href="http://web.archive.org/web/20181114231447/http://morphett.info/turing/turing.html">http://morphett.info/turing/turing.html</a></p>
</section><div><a class="slider-prev" href="#машина-тьюринга-формально"></a><a class="slider-next" href="#универсальная-машина-тьюринга"></a></div>
<section id="универсальная-машина-тьюринга" class="slide level1">
<h1>Универсальная машина Тьюринга</h1>
<p>— машина Тьюринга, которая на вход получает код произвольной машины <em>M</em> и её входные данные, и выполняет машину <em>M</em> на данном входе.</p>
<p>David Bevan, файл utm.pdf по адресу <a href="http://tinyurl.com/M269resources" class="uri">http://tinyurl.com/M269resources</a></p>
<p>Эмулируются машины ленты с алфавитом Γ = { _, 0, 1 }.</p>
<p>Состояние ленты универсальной машины Тьюринга <em>U,</em> эмулирующей машину <em>M</em>:</p>
<p><code class="small">_ _ слева-от-головки [ M' ] текущая-ячейка справа-от-головки _ _</code></p>
<p>M' — код машины с текущим состоянием.</p>
<p>Фактически универсальная машина хранит код головки слева от текущей ячейки эмулируемой машины.</p>
</section><div><a class="slider-prev" href="#интерактивная-демонстрация-машины-тьюринга"></a><a class="slider-next" href="#универсальная-машина-тьюринга-код-машины"></a></div>
<section id="универсальная-машина-тьюринга-код-машины" class="slide level1 small">
<h1>Универсальная машина Тьюринга: код машины</h1>
<p>Пусть M имеет <em>m</em> состояний <em>q<sub>1</sub>, ..., q<sub>m</sub></em>, а состояние машины на текущем шаге (активное состояние) — <em>q<sub>C</sub></em>.</p>
<p>Тогда код машины M' записывается в виде последовательности кодов правил перехода, разделёнными знаком <code>:</code> (состояние на текущем шаге отделяется от следующего знаком <code>!</code>): q'<sub>1</sub>:q'<sub>2</sub>:...:q'<sub>C</sub>!q'<sub>C+1</sub>:...:q'<sub>m</sub></p>
<p>Для правил перехода вида:</p>
<p>q<sub>i</sub>, _ → новый-символ<sub>_</sub>, направление-сдвига<sub>_</sub>, q<sub>j</sub></p>
<p>q<sub>i</sub>, 0 → новый-символ<sub>0</sub>, направление-сдвига<sub>0</sub>, q<sub>k</sub></p>
<p>q<sub>i</sub>, 1 → новый-символ<sub>1</sub>, направление-сдвига<sub>1</sub>, q<sub>l</sub></p>
<p>Код правил перехода записывается через запятую:</p>
<p>новый-символ<sub>_</sub> направление-сдвига<sub>_</sub> σ<sub>i-j</sub> , новый-символ<sub>0</sub> направление-сдвига<sub>0</sub> σ<sub>i-k</sub>, новый-символ<sub>1</sub> направление-сдвига<sub>1</sub> σ<sub>i-l</sub></p>
<p>где σ<sub>a-b</sub> = <code>.</code>, если a = b,</p>
<p>σ<sub>a-b</sub> = <code>+</code><sup>a-b</sup>, если a &gt; b,</p>
<p>σ<sub>a-b</sub> = <code>–</code><sup>b-a</sup>, если a &lt; b</p>
<p>Если пара (состояние, входной-символ) описывают конечное состояние, то его код — пустая последовательность символов.</p>
</section><div><a class="slider-prev" href="#универсальная-машина-тьюринга"></a><a class="slider-next" href="#универсальная-машина-тьюринга-реализация"></a></div>
<section id="универсальная-машина-тьюринга-реализация" class="slide level1 small">
<h1>Универсальная машина Тьюринга: реализация</h1>
<p>Алфавит: <code>_ 0 1 [ ] , : ! L R . + - # &lt; &gt;</code> Перед началом исполнения <em>U</em> устанавливает головку справа от <code>]</code>. Исполняется следующая последовательность действий до остановки на шаге 4:</p>
<ol type="1">
<li class="fragment">Считать символ <em>s</em>.</li>
<li class="fragment">Найти активное состояние сдвигаясь влево до <code>!</code>.</li>
<li class="fragment">Найти подходящее правило перехода: в зависимости от того, равен ли <em>s</em> <code>_</code>, <code>0</code> или <code>1</code> сдвинуться влево от 2-й, 1-й или 0-й запятой, соответственно.</li>
<li class="fragment">Если текущее правило пусто, остановиться.</li>
<li class="fragment">Иначе, пометить активное правило, заменяя значения σ: <code>.</code> на <code>#</code>, <code>+</code> на <code>&gt;</code>, <code>-</code> на <code>&lt;</code>.</li>
<li class="fragment">Считать для активного правила новый-символ<sub><em>s</em></sub>, сдвинуться вправо от <code>]</code> и записать его значение.</li>
<li class="fragment">Вернуться к активному правилу, считать направление-сдвига<sub><em>s</em></sub></li>
<li class="fragment">Сдвинуть виртуальную головку (код M') в направление-сдвига<sub><em>s</em></sub></li>
<li class="fragment">Изменить текущее состояние, если необходимо: если есть символ <code>#</code> (состояние не меняется), он заменяется обратно на <code>.</code>; если есть символ <code>&lt;</code>, поменять <code>!</code> местами с ближайшим слева <code>:</code>, заменить <code>&lt;</code> на <code>-</code>. Повторять пока есть один из символов <code>&lt;#&gt;</code> Аналогично для <code>&gt;</code>.</li>
<li class="fragment">Вернуться вправо от <code>]</code> на новую виртуальную активную ячейку, перейти к шагу 1.</li>
</ol>
</section><div><a class="slider-prev" href="#универсальная-машина-тьюринга-код-машины"></a><a class="slider-next" href="#универсальная-машина-тьюринга-сложность"></a></div>
<section id="универсальная-машина-тьюринга-сложность" class="slide level1">
<h1>Универсальная машина Тьюринга: сложность</h1>
<div style="float: left; width: 30%; font-size: 0.7em">
<p>Шеннон предложил методы реинтерпретации машин Тьюринга с алфавитом размером <em>m</em> и количеством состояний <em>n</em>:</p>
<ul>
<li class="fragment">на машине из двух состояний с алфавитом размером не более <em>4mn + m;</em></li>
<li class="fragment">на машине с алфавитом размера 2, имеющей не более <em>8nm</em> состояний;</li>
<li class="fragment">⇒ Можно «перекачивать» сложность из состояний в алфавит и обратно.</li>
</ul>
График из: Turlough Neary and Damien Woods. 2009. Four Small Universal Turing Machines. Fundam. Inf. 91, 1 (January 2009), 123-144.
</div>
<div style="float: right; width: 60%; font-size: 0.7em" class="nop">
<style>
div.nop > p {
    padding: 0;
    text-indent: 0;
}
</style>
Сейчас оценки сложности универсальной машины Тьюринга следующие: <img data-src="images/universal-turing-counts.png" src="images/universal-turing-counts.png">
</div>
</section><div><a class="slider-prev" href="#универсальная-машина-тьюринга-реализация"></a><a class="slider-next" href="#проблема-останова"></a></div>
<section id="проблема-останова" class="slide level1">
<h1>Проблема останова</h1>
<h2 id="halting-problem">Halting problem</h2>
<p>Можно ли для данной универсальной машины Тьюринга построить алгоритм, который принимает на вход произвольный код программы <code>M</code> и вход <code>I</code>, и выводит 1, если машина <code>M</code> останавливается на входе <code>I</code> и 0, если не останавливается.</p>
<p>[Есть ли общий способ понять, остановится ли заданная машина на заданном входе]</p>
</section><div><a class="slider-prev" href="#универсальная-машина-тьюринга-сложность"></a><a class="slider-next" href="#неразрешимость-проблемы-останова"></a></div>
<section id="неразрешимость-проблемы-останова" class="slide level1">
<h1>Неразрешимость проблемы останова</h1>
<p>Проблема останова неразрешима, такой алгорим построить нельзя. От противного: пусть такой алгоритм построен в виде машины <code>Halt(M, I)</code>. Построим следующую машину <code>Z</code> с одним входом <code>X</code> (машина частичного разрешения):</p>
<pre><code>Если Halt(x, x) то уйти в бесконечный цикл.
Иначе остановиться.</code></pre>
<p>Чему равно <code>Halt(Z, Z)</code>?</p>
<ol type="1">
<li class="fragment">Если машина <code>Z</code> останавливается на входе <code>Z</code>, то <code>Halt(Z, Z)</code> возвращает <code>1</code>. Но тогда машина <code>Z</code> должна уходить в бесконечный цикл на входе <code>Z</code>.</li>
<li class="fragment">Если машина <code>Z</code> не останавливается на входе <code>Z</code>, то <code>Halt(Z, Z)</code> возвращает <code>0</code>. Тогда машина <code>Z</code> должна остановиться на входе <code>Z</code>.</li>
</ol>
<p>Таким образом, <code>Halt</code> не может существовать.</p>
<div class="small">
Источник: <a href="http://www.comp.nus.edu.sg/~cs5234/FAQ/halt.html" class="uri">http://www.comp.nus.edu.sg/~cs5234/FAQ/halt.html</a>
</div>
</section><div><a class="slider-prev" href="#проблема-останова"></a><a class="slider-next" href="#формальные-языки"></a></div>
<section id="формальные-языки" class="slide level1">
<h1>Формальные языки</h1>
<p>Формальный язык <em>L</em> над алфавитом <em>Σ</em> — подмножество всех конечных строк <em>L ⊆ Σ × Σ × … × Σ × …</em>.</p>
<p>Задача разрешения утверждения сводится к задаче определения принадлежности строки заданному утверждением формальному языку.</p>
<p>Пример: проверка числа на простоту = проверка того, принадлежит ли число формальному языку «десятичные записи простых чисел».</p>
</section><div><a class="slider-prev" href="#неразрешимость-проблемы-останова"></a><a class="slider-next" href="#формальная-грамматика"></a></div>
<section id="формальная-грамматика" class="slide level1">
<h1>Формальная грамматика</h1>
<p>— способ задания формального языка (семейства формальных языков) в виде некоторой последовательности правил.</p>
<p>Выделяют:</p>
<ul>
<li class="fragment">распознающие грамматики, которые описывают алгоритм задачи разрешения (является ли число простым?);</li>
<li class="fragment">порождающие грамматики, которые генерируют слово языка (1274-е по порядку простое число);</li>
<li class="fragment">перечисляющие грамматики, которые последовательно выводят все слова языка (вывести все простые числа);</li>
</ul>
</section><div><a class="slider-prev" href="#формальные-языки"></a><a class="slider-next" href="#формальная-грамматика-мотивация"></a></div>
<section id="формальная-грамматика-мотивация" class="slide level1">
<h1>Формальная грамматика: мотивация</h1>
<p><strong>Корректность алгоритма</strong> — свойство, согласно которому для любого входа алгоритм завершается и возвращает решение задачи для этого входа (или, скажем, некоторый признак ошибки, если алгоритм неприменим к заданному входу). Т.е. «программа должна выводить правильный ответ, никогда не падать и никогда не зависать».</p>
<p>В связи с неразрешимостью проблемы останова, мы не можем описать множество всех корректных алгоритмов (решить в общем виде задачу верификации программ). Но можно попробовать ограничить набор задач, которые мы хотим решать так, чтобы все задачи такого ограниченного набора имели решение.</p>
</section><div><a class="slider-prev" href="#формальная-грамматика"></a><a class="slider-next" href="#конечные-автоматы"></a></div>
<section id="конечные-автоматы" class="slide level1">
<h1>Конечные автоматы</h1>
<p>Ограничим машину Тьюринга следующим образом: в начале вычислений головка расположена на первом непустом символе ленты слева, и на каждом шаге продвигается направо, считывая по одному символу. После того, как головка достигла последнего непустого символа входных данных справа, вычисление прекращается.</p>
<p>Получаем модель детерминированного конечного автомата. <strong>Конечный автомат</strong> (finite automaton) — это четвёрка:</p>
<ul>
<li class="fragment"><p>Q — множество состояний</p></li>
<li class="fragment"><p>I, O — входной и выходной алфавит (конечные множества)</p></li>
<li class="fragment"><p>δ : I × Q → O × Q — функция перехода</p></li>
<li class="fragment"><p>q<sub>0</sub> ∈ Q — исходное состояние</p></li>
</ul>
</section><div><a class="slider-prev" href="#формальная-грамматика-мотивация"></a><a class="slider-next" href="#конечные-автоматы-1"></a></div>
<section id="конечные-автоматы-1" class="slide level1">
<h1>Конечные автоматы</h1>
<p><strong>Недетерминированный конечный автомат</strong> может находиться сразу в множестве состояний Q' ⊆ Q; функция перехода, таким образом, определена на множестве подмножеств Q. Они эквивалентны детерминированным конечным автоматам, которые имеют множество состояний 2<sup>Q</sup>.</p>
<p><strong>Распознающий автомат</strong> — рассматриваем автомат без выхода и выделяем подмножество конечных (распознающих) состояний F ⊂ Q. Если после обработки последнего символа входного слова распознающий автомат находится в состоянии f ∈ F, то автомат распознал слово.</p>
</section><div><a class="slider-prev" href="#конечные-автоматы"></a><a class="slider-next" href="#регулярные-языки"></a></div>
<section id="регулярные-языки" class="slide level1">
<h1>Регулярные языки</h1>
<p>Индуктивное определение:</p>
<p>Пустое слово ⊘ и пустой язык { <code>_</code> } — регулярные языки.</p>
<p>Для любой буквы алфавита a ∈ Γ, { a } — регулярный язык.</p>
<p>Объединение регулярных языков — регулярный язык { a } ∪ { b } = { a, b }.</p>
<p>Конкатенация регулярных языков — регулярный язык { a } · { b } = { ab } (последовательность из слов первого языка, за которыми идут слова второго языка).</p>
<p>Звёздочка Клини для регулярного языка — регулярный язык { a, b }* = { ε, a, b, aaa, abab, … } (последовательности любой длины из слов исходного языка).</p>
<p>Языки, которые не могут быть построены перечисленными конструкторами — не регулярны.</p>
</section><div><a class="slider-prev" href="#конечные-автоматы-1"></a><a class="slider-next" href="#теорема-клини"></a></div>
<section id="теорема-клини" class="slide level1">
<h1>Теорема Клини</h1>
<p>Регулярные языки в точности соответствуют формальным языкам, которые может распознать конечный распознающий автомат. <a href="http://neerc.ifmo.ru/wiki/index.php?title=%D0%A2%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0_%D0%9A%D0%BB%D0%B8%D0%BD%D0%B8_(%D1%81%D0%BE%D0%B2%D0%BF%D0%B0%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%BE%D0%B2_%D0%B0%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%BD%D1%8B%D1%85_%D0%B8_%D1%80%D0%B5%D0%B3%D1%83%D0%BB%D1%8F%D1%80%D0%BD%D1%8B%D1%85_%D1%8F%D0%B7%D1%8B%D0%BA%D0%BE%D0%B2)">Схема доказательства</a>:</p>
<div style="float: left; width: 40%">
<strong>Регулярные языки распознаются недетерминированными конечными автоматами.</strong> По индукции по построению регулярного языка. Используется графовое представление автомата: узлы — состояния; ориентированные рёбра, помеченные символами входного алфавита — переходы; двойным контуром отмечены распознающие состояния.
</div>
<div style="float:right; width: 40%">
<img data-src="images/lec35-re-to-nfa.svg" alt="from: http://www.cs.cornell.edu/courses/cs2800/2016sp/lectures/lec35-re-to-nfa.svg" src="images/lec35-re-to-nfa.svg">
</div>
</section><div><a class="slider-prev" href="#регулярные-языки"></a><a class="slider-next" href="#теорема-клини-1"></a></div>
<section id="теорема-клини-1" class="slide level1">
<h1>Теорема Клини</h1>
<p><a href="http://www.cs.cornell.edu/courses/cs2800/2016sp/lectures/lec35-kleene.html"><strong>Языки, распознаваемые автоматами, регулярны.</strong></a> Расширим графовое представление конечного автомата: разрешим помечать рёбра регулярными выражениями. Приведём автомат к виду с единственным конечным состоянием (если конечных состояний несколько, добавим новое конечное состояние и проведём рёбра, помеченные ε). Будем последовательно удалять промежуточные состояния: <img data-src="images/lec35-nfa-reduction.svg" src="images/lec35-nfa-reduction.svg"></p>
<p>В завершение процесса останется автомат с одним начальным и одним конечным состоянием: <img data-src="images/lec35-reduced.svg" src="images/lec35-reduced.svg"></p>
<p>Тогда эквивалентное регулярное выражение: (r<sub>1</sub> | r<sub>2</sub> r<sub>4</sub><sup>*</sup> r<sub>3</sub>)<sup>*</sup> r<sub>2</sub> r<sub>4</sub><sup>*</sup></p>
</section><div><a class="slider-prev" href="#теорема-клини"></a><a class="slider-next" href="#лемма-о-накачке-для-регулярного-языка"></a></div>
<section id="лемма-о-накачке-для-регулярного-языка" class="slide level1">
<h1>Лемма о накачке для регулярного языка</h1>
<p>Какими свойствами ограничены регулярные языки? Все конечные языки регулярны, поэтому рассмотрим только бесконечные. Оказывается, для любого бесконечного регулярного языка у всех достаточно длинных слов можно копировать «середину» сколько угодно раз так, что получающаяся в итоге строка тоже будет принадлежать языку.</p>
<p>Формально: если L — бесконечный регулярный язык, то существует натуральное n &gt; 0, такое, что в любом слове x ∈ L длиннее, чем n, можно выделить части u, v, w (x = u·v·w), так, что |uv| &lt; n, |v| &gt; 0 и для всех k &gt; 0, u·v<sup>k</sup>·w ∈ L.</p>
<p>Применение: если в языке для любого n можно получить такое слово, для которого никакую «середину» нельзя повторить, оставаясь в языке, то этот язык нерегулярный. Пример: L = { 0<sup>n</sup>1<sup>n</sup> | n ⩾ 0}.</p>
</section><div><a class="slider-prev" href="#теорема-клини-1"></a><a class="slider-next" href="#схема-доказательства-леммы-о-накачке"></a></div>
<section id="схема-доказательства-леммы-о-накачке" class="slide level1">
<h1>Схема доказательства леммы о накачке</h1>
<p>Общая схема доказательств: строим <em>детерминированный</em> конечный автомат для L. Возьмём n — число состояний. После обработки первых n букв слова x автомат принимает n+1 состояние, т.е. хотя бы два из них одинаковы. Таким образом, в ориентированном графе состояний есть цикл. Выделим цикл и возьмём в качестве «середины» v ту часть x, которая полностью проходит этот цикл.</p>
<p>Мы можем сколько угодно раз копировать «середину» — и при распознавании автомат будет ходить по этому циклу, но после завершения он всё пойдёт по тому же пути для конца слова w, что и для исходного слова x.</p>
</section><div><a class="slider-prev" href="#лемма-о-накачке-для-регулярного-языка"></a><a class="slider-next" href="#контекстно-свободные-языки-и-мп-автоматы"></a></div>
<section id="контекстно-свободные-языки-и-мп-автоматы" class="slide level1">
<h1>Контекстно-свободные языки и МП-автоматы</h1>
<p>— генерируются контекстно-свободной грамматикой, распознаются автоматом с магазинной памятью. <strong>Автомат с магазинной памятью</strong> — конечный автомат со сколь угодно большим стеком. На каждом шаге автомат может положить символ на вершину стека или снять символ с вершины стека. <img data-src="images/Pushdown-overview.svg" src="images/Pushdown-overview.svg"></p>
<h2 id="лемма-о-накачке-для-контекстно-свободного-языка">Лемма о накачке для контекстно-свободного языка</h2>
<p>Формулировка аналогична случаю регулярных языков, но слово = u v w x y, удлинняющееся слово — u v<sup>n</sup> w x<sup>n</sup> y. Неформально — разбор w оставляет стек в том же состоянии, что и приняло, разбор v пополняет стек, разбор x снимает со стека данные, записанные при разборе v.</p>
</section><div><a class="slider-prev" href="#схема-доказательства-леммы-о-накачке"></a><a class="slider-next" href="#иерархия-хомского"></a></div>
<section id="иерархия-хомского" class="slide level1">
<h1>Иерархия Хомского</h1>
<p>(Noam Chomsky, 1956)</p>
<ul>
<li class="fragment">регулярные языки: ∅, a ∈ Σ, A ∪ B, A ∩ B, A<sup>*</sup> (любой конечный язык и некоторые бесконечные; распознаются детерминированным конечным автоматом)</li>
<li class="fragment">контекстно-свободные языки (произвольное количество парных скобок <span class="math inline">(<sup><em>n</em></sup>)<sup><em>n</em></sup></span> — контекстно-свободный язык, распознаются автоматом с магазинной памятью (стеком))</li>
<li class="fragment">контекстно-зависимые языки (произвольное количество троек <span class="math inline">(<sup><em>n</em></sup>|<sup><em>n</em></sup>)<sup><em>n</em></sup></span> — контекстно-зависимый язык, распознаются линейно-ограниченным автоматом — машиной Тьюринга с лентой, длина которой линейно зависит от длины входа)</li>
<li class="fragment">неограниченные языки (распознаются машиной Тьюринга)</li>
</ul>
</section><div><a class="slider-prev" href="#контекстно-свободные-языки-и-мп-автоматы"></a><a class="slider-next" href="#контекстно-зависимые-языки-на-практике"></a></div>
<section id="контекстно-зависимые-языки-на-практике" class="slide level1">
<h1>Контекстно-зависимые языки на практике</h1>
<p>Если есть алгоритм, который решает задачу с использованием линейного количества дополнительной памяти (относительно длины кодированных входных данных), то алгоритм можно реализовать для линейно-ограниченного автомата и, следовательно, можно построить контекстно-зависимую грамматику.</p>
<p>Пример задачи проверки простоты числа — контекстно-зависимый.</p>
</section><div><a class="slider-prev" href="#иерархия-хомского"></a><a class="slider-next" href="#пространства-сложности"></a></div>
<section id="пространства-сложности" class="slide level1">
<h1>Пространства сложности</h1>
<p><code>P</code> — распознаётся детерминированной машиной Тьюринга за количество шагов (время), полиномиальное по длине входа.</p>
<p><code>NP</code> — время выражается как полином для <em>недетерминированной</em> машины Тьюринга (неформальное определение — «ответ можно проверить за полиномиальное время»)</p>
<p><code>NPC</code> — любая задача из <code>NP</code> за полиномиальное время может быть сведена к такой задаче</p>
</section><div><a class="slider-prev" href="#контекстно-зависимые-языки-на-практике"></a><a class="slider-next" href="#busy-beaver"></a></div>
<section id="busy-beaver" class="slide level1">
<h1>Busy beaver</h1>
<p>Задача: построить всегда останавливающуюся машину Тьюринга на двоичном алфавите, которая записывает наибольшее число <code>1</code> на ленту, используя ограниченное количество состояний (или которая выполняет наибольшее количество шагов без остановки).</p>
<p>Известны следующие реализации:</p>
<p>2 состояния — 6 шагов, 4 единицы</p>
<p>3 состояния — 21 шаг, 6 единиц</p>
<p>4 состояния — 107 шагов, 13 единиц</p>
<p>5 состояний — ⩾ 47 млн шагов, ⩾ 4098 единиц</p>
<p>6 состояний — &gt; 7.4 · 10<sup>36534</sup></p>
</section><div><a class="slider-prev" href="#пространства-сложности"></a><a class="slider-next" href="#задачи"></a></div>
<section id="задачи" class="slide level1">
<h1>Задачи</h1>
<dl>
<dt class="fragment"><strong>Задача 2.1. **</strong></dt>
<dd class="fragment">В предположении, что задан код <code>Halt</code>, реализовать машину <code>Z</code> в интерпретаторе универсальной машины Тьюринга.
</dd>
<dt class="fragment"><strong>Задача 2.2. **</strong></dt>
<dd class="fragment">Написать интерактивный эмулятор машины Тьюринга. Эмулятор должен допускать описание машины (в каком-то виде); пошаговое исполнение с выводом состояния на каждом шаге; исполнение до останова.
</dd>
<dt class="fragment"><strong>Задача 2.3а *</strong></dt>
<dd class="fragment">Привести пример контекстно-свободного, не регулярного языка (не a<sup>n</sup>b<sup>n</sup>) с доказательством.
</dd>
<dt class="fragment"><strong>Задача 2.3б *</strong></dt>
<dd class="fragment">Привести пример контекстно-зависимого, не контекстно свободного языка (не a<sup>n</sup>b<sup>n</sup>c<sup>n</sup>) с доказательством.
</dd>
<dt class="fragment"><strong>Задача 2.3в **</strong></dt>
<dd class="fragment">Привести пример неограниченного языка (с доказательством того, что он является неограниченным).
</dd>
</dl>
</section><div><a class="slider-prev" href="#busy-beaver"></a><a class="slider-next" href="#задачи-1"></a></div>
<section id="задачи-1" class="slide level1">
<h1>Задачи</h1>
<dl>
<dt class="fragment"><strong>Задача 2.4а. *</strong></dt>
<dd class="fragment">Реализовать в интерпретаторе машины Тьюринга сравнение двух унарных чисел (на входе — два унарных числа, на выходе — 0, если первое больше второго и 1 — если второе больше первого или они равны).
</dd>
<dt class="fragment"><strong>Задача 2.4б. **</strong></dt>
<dd class="fragment">Реализовать в интерпретаторе машины Тьюринга унарное деление с остатком (на входе — два унарных числа, разделённых нулём; на выходе — частное и остаток).
</dd>
<dt class="fragment"><strong>Задача 2.5. ***</strong></dt>
<dd class="fragment">Мини-обзор (хотя бы 10 статей/книг, по каждой — описание в 2-4 предложениях) по тематике «Ограничения машин Тьюринга, гарантирующие завершимость программ» (за пределами рассмотренных конечных автоматов, автоматов с магазинной памяьтю и линейно-ограниченных автоматов).
</dd>
<dt class="fragment"><strong>Задача 2.6. **</strong></dt>
<dd class="fragment">Найти содержательную арифметическую задачу, решение которой — контекстно-свободный язык.
</dd>
</dl>
</section><div><a class="slider-prev" href="#задачи"></a><a class="slider-next"></a></div>

<!-- start page -->
   <div id="slider">
       <a href="#математические-модели-вычислений" class="slider-start">PLAY</a>
   </div>

   <!-- progressbar container -->
   <div class="slider-progress"></div>
   </article>
  </div>

  
  <script type="text/javascript">
  document.addEventListener("keydown", function(e) {
     if (e.altKey || e.ctrlKey || e.metaKey || e.shiftKey) { return; }
     switch (e.keyCode) {
       case 35: // End
          var arr = document.querySelectorAll("a.slider-next:link");
          var a = arr[arr.length - 1];
          if (a && a.href) {
            window.location = a.href;
          }
          break;
       case 36: // Home
          var a = document.querySelector("a.slider-start");
          if (a && a.href) {
            window.location = a.href;
          }
          break;
       case 37: // left arrow
         var a = document.querySelector("section:target ~ div a.slider-prev");
         if (a && a.href) {
           window.location = a.href;
         }
         break;
       case 39: // right arrow
         var a = document.querySelector("section:target ~ div a.slider-next");
         if (a && a.href) {
           window.location = a.href;
         }
         break;
     }
  });
  </script>
  

</body></html>

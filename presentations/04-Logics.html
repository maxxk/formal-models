<!DOCTYPE html><html><head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title>04-Logics</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="slider.css">
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
  <div style="width: 640px;height: 400px;">
  <input id="slider-max" type="checkbox" checked="">
   <article class="slider slider-indicator">
   <a id="slider-default"></a>
   <label for="slider-max" title="Maximize"></label>


<section id="математические-модели-вычислений" class="slide level1">
<h1>Математические модели вычислений</h1>
<h2 id="тезис-чёрча-тьюринга-теорема-райса-о-неразрешимости-нетривиальных-свойств">Тезис Чёрча-Тьюринга. Теорема Райса о неразрешимости нетривиальных свойств.</h2>
<h2 id="формальные-системы-полнота-и-непротиворечивость-теоремы-гёделя-о-неполноте">Формальные системы. Полнота и непротиворечивость. Теоремы Гёделя о неполноте.</h2>
<h2 id="теоретико-модельные-и-теоретико-доказательные-подходы-к-верификации">Теоретико-модельные и теоретико-доказательные подходы к верификации.</h2>
<p><a href="mailto:maxim.krivchikov@gmail.com" class="email">maxim.krivchikov@gmail.com</a></p>
<p>Материалы курса: <a href="https://maxxk.github.io/formal-models/" class="uri">https://maxxk.github.io/formal-models/</a></p>
</section><div><a class="slider-prev"></a><a class="slider-next" href="#тезис-чёрча-тьюринга"></a></div>
<section id="тезис-чёрча-тьюринга" class="slide level1">
<h1>Тезис Чёрча-Тьюринга</h1>
<p>Исходная задача для Entscheidungsproblem — получить строгое понятие алгоритма (вычислимой функции). Под вычислимой понимается функция, значение которой для некоторого заданного аргумента может получить человек с использованием алгоритма (последовательности шагов с условиями).</p>
<p><strong>Определение</strong> <em>(Тезис Чёрча-Тьюринга).</em> Вычислимые функции — это функции, которые можно вычислить с использованием машины Тьюринга или другой эквивалентной модели.</p>
<h2 id="определение-понятия-программы">«Определение» понятия программы</h2>
<p>Программой, решающей определённую задачу, назовём код машины Тьюринга, которая реализует решение задачи, в терминах некоторой универсальной машины Тьюринга, или эквивалентной ей модели вычислений.</p>
</section><div><a class="slider-prev" href="#математические-модели-вычислений"></a><a class="slider-next" href="#относительная-сложность-математических-проблем"></a></div>
<section id="относительная-сложность-математических-проблем" class="slide level1">
<h1>Относительная сложность математических проблем</h1>
<p>По следующей ссылке: <a href="http://www.scottaaronson.com/blog/?p=2725" class="uri">http://www.scottaaronson.com/blog/?p=2725</a> представлены результаты работы (в том числе — препринт статьи, исходный код, видеолекция и т.д.), авторы и последователи которой построили с помощью компилятора/интерпретатора с языка программирования относительно высокого уровня в машину Тьюринга, следующие машины на двоичном алфавите:</p>
<ul>
<li class="fragment">машина из 4888 состояний, которая останавливается в том и только в том случае, когда существует контрпример к гипотезе Гольдбаха</li>
<li class="fragment">машина из 744 состояний, которая останавливается в том и только в том случае, когда существует контрпример к гипотезе Римана</li>
<li class="fragment">машина из 1919 состояний, которая останавливается в том и только в том случае, если найдена противоречивая формула, выводимая в ZFC (т.е. машина, останов которой в недоказуем в ZFC)</li>
</ul>
</section><div><a class="slider-prev" href="#тезис-чёрча-тьюринга"></a><a class="slider-next" href="#теорема-райса-о-неразрешимости-нетривиальных-свойств-частичных-функций"></a></div>
<section id="теорема-райса-о-неразрешимости-нетривиальных-свойств-частичных-функций" class="slide level1">
<h1>Теорема Райса о неразрешимости нетривиальных свойств частичных функций</h1>
<p><em>Исходная формулировка — в терминах частично-рекурсивных функций Клини — другой универсальной модели вычислений, эквивалентной машине Тьюринга.</em> Для любого нетривиального свойства частичных функций не существует общего эффективного метода разрешения того, вычисляет ли данный алгоритм частичную функцию с таким свойством. Тривиальные свойства — свойства, которые выполняются для всех вычислимых функций (или не выполняются ни для одной).</p>
<p>Частичная функция из <em>X</em> в <em>Y</em> — функция, область определения которой не совпадает со всем <em>X</em>. Вычислимые функции частичны, т.к. можно представить машину Тьюринга, которая останавливается для некоторых входных значений и не останавливается для других.</p>
<p>В терминах «программ» универсального вычислителя: для любого нетривиального <em>семантического</em> свойства программ не существует общего эффективного метода разрешения того, обладает ли данная программа таким свойством.</p>
</section><div><a class="slider-prev" href="#относительная-сложность-математических-проблем"></a><a class="slider-next" href="#теорема-райса"></a></div>
<section id="теорема-райса" class="slide level1">
<h1>Теорема Райса</h1>
<h2 id="следствие-для-практики">Следствие для практики</h2>
<p>Невозможно создать алгоритм, который определяет, обладает ли произвольная программа некоторым нетривиальным свойством.</p>
<p>⇒ невозожна автоматическая формальная верификация</p>
<h2 id="в-терминах-распознающих-машин-тьюринга">В терминах распознающих машин Тьюринга</h2>
<p>Пусть <em>S</em> — нетривиальное множество языков (т.е. ни *S*, ни его дополнение не пусты), и существуют две машины Тьюринга — распознающая, что язык находится в <em>S</em> и распознающая, что язык не находится в <em>S</em>. Тогда для произвольной данной машины Тьюринга вопрос о том, принадлежит ли распознаваемый ей язык <em>S</em> является неразрешимым.</p>
</section><div><a class="slider-prev" href="#теорема-райса-о-неразрешимости-нетривиальных-свойств-частичных-функций"></a><a class="slider-next" href="#теорема-райса-1"></a></div>
<section id="теорема-райса-1" class="slide level1">
<h1>Теорема Райса</h1>
<h2 id="схема-доказательства">Схема доказательства</h2>
<p>Сводим утверждение теоремы к проблеме останова. Пусть:</p>
<ul>
<li class="fragment"><em>a</em> — строка-программа</li>
<li class="fragment"><em>a ↦ 𝐅<sub>a</sub></em> — частичная функция, соответствующая программе <em>a</em></li>
<li class="fragment"><em>a ↦ P(a)</em> — данный алгоритм, разрешающий некоторое нетривиальное свойство</li>
<li class="fragment"><em>n</em> — строка-программа, которая не завершается ни для какого входа (бесконечный цикл)</li>
<li class="fragment">без ограничения общности, <em>P(n) = 0</em></li>
<li class="fragment"><em>b</em> — строка-программа, для которой <em>P(b) = 1</em> (по условию нетривиальности свойства)</li>
</ul>
<p>Покажем, что из этих элементов можно создать алгоритм <em>H(a, i)</em>, решающий проблему останова для программы <em>a</em> на входе <em>i</em>. Построим <em>t</em> — строку-программу, которая для входа <em>j</em> выполняет вычисление <em>𝐅<sub>a(i)</sub>,</em> затем — <em>𝐅<sub>b(j)</sub></em> и возвращает последний результат.</p>
<p>Тогда <em>P(t)</em> решает проблему останова.</p>
</section><div><a class="slider-prev" href="#теорема-райса"></a><a class="slider-next" href="#теорема-райса-2"></a></div>
<section id="теорема-райса-2" class="slide level1">
<h1>Теорема Райса</h1>
<h2 id="пояснение">Пояснение</h2>
<p>Теорема существенно опирается на тот факт, что мы отождествляем все программы, которые реализуют одну и ту же функцию, т.е. рассматриваем семантику программы, игнорируя её синтаксис. Такое отождествление называется «функциональная экстензиональность».</p>
<p><em>P(t)</em> решает проблему останова, т.к.:</p>
<ol type="1">
<li class="fragment">Если <em>a</em> завершается на <em>i</em>, то 𝐅<sub>t</sub> = 𝐅<sub>b</sub> и <em>H(a, i)</em> = 1</li>
<li class="fragment">Если <em>a</em> не завершается на <em>i</em>, то 𝐅<sub>t</sub> = 𝐅<sub>n</sub> (никогда не завершается) и <em>H(a, i)</em> = 0</li>
</ol>
</section><div><a class="slider-prev" href="#теорема-райса-1"></a><a class="slider-next" href="#программа-гильберта"></a></div>
<section id="программа-гильберта" class="slide level1">
<h1>Программа Гильберта</h1>
<p>Искомые свойства формальной системы для оснований математики:</p>
<ol type="1">
<li class="fragment">Полнота (мы можем переписыванием получить из аксиом все истинные утверждения математики)</li>
<li class="fragment">Непротиворечивость (мы не можем получить переписыванием из аксиом ложное утверждение)</li>
<li class="fragment">Разрешимость (руководствуясь простым набором правил можно для любой формулы получить, выводима она или нет).</li>
</ol>
</section><div><a class="slider-prev" href="#теорема-райса-2"></a><a class="slider-next" href="#формальная-система"></a></div>
<section id="формальная-система" class="slide level1">
<h1>Формальная система</h1>
<p>— конструкция, отражающая концепцию формализма: теории представляются в виде формул, которые можно менять по заданным правилам Составные части:</p>
<ol type="1">
<li class="fragment">Конечный <em>алфавит</em>, из символов которого составляются <em>формулы</em> — строки.</li>
<li class="fragment"><em>Грамматика</em> — набор правил, описывающий как составить корректно сформированные формулы (<em>well-formed formulas</em>, <strong>wf</strong>). Часто под грамматикой подразумевается процедура разрешения, является ли формула корректно сформированной.</li>
<li class="fragment"><em>Схемы аксиом</em> — набор корректно сформированных формул (или схем формул — формул с «метапеременными», вместо которых можно подставлять произвольные формулы).</li>
<li class="fragment"><em>Правила вывода</em> — правила, по которым из нескольких корректно сформированных формул, удовлетворяющих некоторой схеме, можно получить новую корректно сформированную формулу.</li>
</ol>
</section><div><a class="slider-prev" href="#программа-гильберта"></a><a class="slider-next" href="#пример-исчисление-высказываний"></a></div>
<section id="пример-исчисление-высказываний" class="slide level1">
<h1>Пример: исчисление высказываний</h1>
<ol type="1">
<li class="fragment">Алфавит:
<ul>
<li class="fragment"><em>переменные</em> (<em>a, b, c, …, a<sub>1</sub>, b<sub>1</sub>, c<sub>1</sub>, …</em>)</li>
<li class="fragment"><em>логические операторы</em> (¬, ∧, ∨, ⊕, →, ↔︎)</li>
<li class="fragment"><em>технические символы</em> (скобки — (), [])</li>
</ul></li>
<li class="fragment">Грамматика: переменная <strong>wf</strong>; формула в скобках <strong>wf</strong>;</li>
</ol>
<p>отрицание — унарный префиксный оператор с высшим приоритетом связывания;</p>
<p>остальные — бинарные операторы,</p>
<p>приоритет и ассоциативность других операторов не определены, если не указано обратное (нужно всё брать в скобки — но вообще проще предполагать, что правила работают с синтаксическими деревьями)</p>
</section><div><a class="slider-prev" href="#формальная-система"></a><a class="slider-next" href="#исчисление-высказываний"></a></div>
<section id="исчисление-высказываний" class="slide level1">
<h1>Исчисление высказываний</h1>
<ol start="3" type="1">
<li class="fragment">Аксиомы (11 схем аксиом, далее ссылаемся с префиксом A):</li>
</ol>
<p>Импликация:</p>
<ol type="a">
<li class="fragment"><em>A → (B → A)</em> — абстракция,</li>
<li class="fragment"><em>(A → (B → C)) → ((A → B) → (A → C))</em> — композиция,</li>
</ol>
<p>Конъюнкция:</p>
<ol start="3" type="a">
<li class="fragment"><em>(A ∧ B) → A</em> — выделение формулы слева,</li>
<li class="fragment"><em>(A ∧ B) → B</em> — выделение формулы справа,</li>
<li class="fragment"><em>[A → B] → [(A → C) → (A → (B ∧ C))]</em> — конструктор конъюнкции,</li>
</ol>
<p>Дизъюнкция:</p>
<ol start="6" type="a">
<li class="fragment"><em>A → (A ∨ B)</em> — конструктор дизъюнкции слева,</li>
<li class="fragment"><em>B → (A ∨ B)</em> — конструктор дизъюнкции справа,</li>
<li class="fragment"><em>[A → C] → [(B → C) → ((A ∨ B) → C)]</em> — разбор случаев,</li>
</ol>
<p>Отрицание:</p>
<ol type="i">
<li class="fragment"><em>(A → B) ⟶ (¬B → ¬A)</em> — контрапозитивное высказывание,</li>
</ol>
<ol start="10" type="a">
<li class="fragment"><em>A → ¬¬A</em></li>
<li class="fragment"><em>¬¬A → A</em> (аксиома двойного отрицания, double negation) или <em>A ∨ ¬A</em> (закон исключённого третьего, law of excluded middle, LEM)</li>
</ol>
</section><div><a class="slider-prev" href="#пример-исчисление-высказываний"></a><a class="slider-next" href="#исчисление-высказываний-1"></a></div>
<section id="исчисление-высказываний-1" class="slide level1">
<h1>Исчисление высказываний</h1>
<ol start="4" type="1">
<li class="fragment">Правило вывода (<em>modus ponens</em>, дословно «правило вывода», MP)</li>
</ol>
<p>Для краткости правила вывода и вообще отношение выводимости записывают с помощью символа ⊦.</p>
<p><em>P, P → Q ⊦ Q</em> — «применение функции»</p>
<p>Нас интересуют общезначимые формулы исчисления высказываний — формулы, истинные при любых наборах переменных.</p>
<p><strong>Определение.</strong> Формула <em>выводима</em>, если её можно построить из аксиом и правил вывода. <em>Вывод</em> — конечная последовательность формул, каждый из элементов которой является аксиомой, либо получается применением правила вывода к нескольким из предыдущих формул.</p>
</section><div><a class="slider-prev" href="#исчисление-высказываний"></a><a class="slider-next" href="#исчисление-высказываний-2"></a></div>
<section id="исчисление-высказываний-2" class="slide level1">
<h1>Исчисление высказываний</h1>
<style>table td { padding-right: 2em; }</style>
<p><strong>Пример.</strong> <em>A → A</em> выводима. Приведём вывод (ссылаемся на предыдущие с префиксом F):</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">1. <em>(A → ((A → A) → A)) → ((A → (A → A)) → (A → A))</em></td>
<td style="text-align: left;">[A-b: A,C := A; B := (A → A)]</td>
</tr>
<tr class="even">
<td style="text-align: left;">2. <em>A → ((A → A) → A)</em></td>
<td style="text-align: left;">[A-a: A := A, B := (A → A)]</td>
</tr>
<tr class="odd">
<td style="text-align: left;">3. <em>(A → (A → A)) → (A → A)</em></td>
<td style="text-align: left;">[MP: P:= F2; (P → Q) := F1]</td>
</tr>
<tr class="even">
<td style="text-align: left;">4. <em>A → (A → A)</em></td>
<td style="text-align: left;">[A-a: A, B := A]</td>
</tr>
<tr class="odd">
<td style="text-align: left;">5. <em>A → A</em></td>
<td style="text-align: left;">[MP: P := F4, (P → Q) := F3]</td>
</tr>
</tbody>
</table>
<p><strong>Замечание.</strong> Использовались только аксиомы группы импликации и правило MP, в котором тоже фигурирует только оператор импликации.</p>
</section><div><a class="slider-prev" href="#исчисление-высказываний-1"></a><a class="slider-next" href="#интерпретация-формальной-системы"></a></div>
<section id="интерпретация-формальной-системы" class="slide level1">
<h1>Интерпретация формальной системы</h1>
<p>— множество допустимых значений переменных и способ перевода синтаксически корректных формул системы в функции на этом множестве.</p>
<p>Обычно интерпретация определяет истинность формул системы в виде соответствия: <em>(формула, значения всех переменных) → { истина, ложь }</em></p>
<h2 id="модель-формальной-системы">Модель формальной системы</h2>
<p>— интерпретация, в которой все аксиомы общезначимы.</p>
<p>Если выводимая формула верна во всех моделях — она общезначима. Если выводимая формула неверна во всех моделях — система противоречива. Если формула верна не во всех моделях, она невыводима и является независимой от системы аксиом.</p>
<p>Пример относительно простого исследования аксиоматики ZFC на предмет независимости аксиом: <a href="http://projecteuclid.org/euclid.ndjfl/1093888220" class="uri">http://projecteuclid.org/euclid.ndjfl/1093888220</a></p>
<p>Более подробно про формальные системы можно почитать здесь: <a href="http://lpcs.math.msu.su/~zolin/ax/pdf/2015_Axiomatic_method_Zolin_Lectures.pdf" class="uri">http://lpcs.math.msu.su/~zolin/ax/pdf/2015_Axiomatic_method_Zolin_Lectures.pdf</a></p>
</section><div><a class="slider-prev" href="#исчисление-высказываний-2"></a><a class="slider-next" href="#исчисление-высказываний-основные-свойства"></a></div>
<section id="исчисление-высказываний-основные-свойства" class="slide level1">
<h1>Исчисление высказываний: основные свойства</h1>
<p>Стандартная модель — алгебра логики (булева алгебра).</p>
<p><strong>Теорема.</strong> Любая выводимая формула исчисления высказываний общезначима.</p>
<p><strong>Определение.</strong> Исчисление <em>непротиворечиво</em>, если не существует <strong>wf</strong> выводимой формулы, для которой выводимо её отрицание.</p>
<p><strong>Следствие.</strong> (о непротиворечивости исчисления высказываний) Исчисление высказываний непротиворечиво.</p>
<p><strong>Определение.</strong> Исчисление <em>полно</em>, если в нём выводимы все истинные формулы.</p>
<p><strong>Теорема.</strong> Исчисление высказываний полно — все общезначимые формулы в нём выводимы.</p>
<p><strong>Определение.</strong> Система аксиом <em>независима</em>, если в ней нет аксиом, которые можно вывести из других входящих в систему.</p>
</section><div><a class="slider-prev" href="#интерпретация-формальной-системы"></a><a class="slider-next" href="#пример-исчисление-предикатов"></a></div>
<section id="пример-исчисление-предикатов" class="slide level1">
<h1>Пример: исчисление предикатов</h1>
<h2 id="логика-первого-порядка">логика первого порядка</h2>
<ol type="1">
<li class="fragment">Алфавит — логические и не логические символы
<ul>
<li class="fragment">логические: квантификаторы ∀, ∃; связки (→, ¬, возможно, дополнительные); технические знаки (скобки, пунктуация), переменные, символ равенства</li>
<li class="fragment">не логические: <em>n</em>-арные предикатные символы функциональные символы
<ul>
<li class="fragment">предикат это «высказывание об объектах», функция — «преобразование объектов»</li>
</ul></li>
</ul></li>
<li class="fragment">Синтаксис: термы и формулы
<ul>
<li class="fragment">термы — переменные или функции от термов со всеми аргументами</li>
<li class="fragment">формулы — как в исчислении высказываний, а также:
<ul>
<li class="fragment">предикатные символы от термов со всеми заданными аргументами</li>
<li class="fragment">квантификаторы, связывающие переменную (∀x P(f(x)), ∃y Q(g(y)))</li>
</ul></li>
</ul></li>
</ol>
</section><div><a class="slider-prev" href="#исчисление-высказываний-основные-свойства"></a><a class="slider-next" href="#логика-первого-порядка-1"></a></div>
<section id="логика-первого-порядка-1" class="slide level1">
<h1>Логика первого порядка</h1>
<ol start="3" type="1">
<li class="fragment">Аксиомы
<ol type="1">
<li class="fragment">Все аксиомы исчисления высказываний.</li>
<li class="fragment">∀x.A(x) → A(y)</li>
<li class="fragment">A(x) → ∃y.A(y)</li>
<li class="fragment">Дополнительные аксиомы для предикатных и функциональных символов.</li>
</ol></li>
<li class="fragment">Правила вывода
<ol type="1">
<li class="fragment">A → B, A ⊦ B</li>
<li class="fragment">B → A(x) ⊦ B → ∀x.A(x), где <em>x</em> — не свободная переменная <em>B</em></li>
<li class="fragment">A(x) → B ⊦ ∃x.A(x) → B, где <em>x</em> — не свободная переменная <em>B</em></li>
<li class="fragment">Переименование переменных.</li>
</ol></li>
</ol>
</section><div><a class="slider-prev" href="#пример-исчисление-предикатов"></a><a class="slider-next" href="#арифметика-робинсона"></a></div>
<section id="арифметика-робинсона" class="slide level1">
<h1>Арифметика Робинсона</h1>
<p>Логика первого порядка над следующей сигнатурой:</p>
<ul>
<li class="fragment">0-местный функциональный символ <em>0</em>,</li>
<li class="fragment">1-местный функциональный символ ' («следующее натуральное число», x' = x+1),</li>
<li class="fragment">2-местные символы = (предикатный) и +, × (функциональные).</li>
</ul>
<p>Аксиомы:</p>
<ul>
<li class="fragment">¬(0 = x') — 0 не равен x+1</li>
<li class="fragment">x' = y' → x = y — равенство ненулевых значений</li>
<li class="fragment">¬(x = 0) → ∃y(x = y') — ненулевое значение следует за некоторым значением</li>
<li class="fragment">x + 0 = x — 0 нейтрален по сложению</li>
<li class="fragment">x + y' = (x + y)'</li>
<li class="fragment">x × 0 = 0</li>
<li class="fragment">x × y' = (x × y) + x — дистрибутивность умножения</li>
</ul>
</section><div><a class="slider-prev" href="#логика-первого-порядка-1"></a><a class="slider-next" href="#первая-теорема-гёделя-о-неполноте"></a></div>
<section id="первая-теорема-гёделя-о-неполноте" class="slide level1">
<h1>Первая теорема Гёделя о неполноте</h1>
<p>Если формальная система достаточно выразительна для описания элементарной арифметики, она не может быть одновременно непротиворечива и полна. Для непротиворечивой теории существуют утверждения (формулы), которые не могут быть ни выведены, ни опровергнуты.&nbsp;</p>
<p>Основная идея: достаточно выразительная формальная система не может быть одновременно полна и непротиворечива.</p>
<p>В настоящем курсе мы рассмотрим простую схему доказательства более слабой теоремы, которая соответствует этой идее. А именно:</p>
<p>Формальная система, <em>достаточно выразительная для описания утверждений о машинах Тьюринга,</em> не может быть одновременно непротиворечива и полна.</p>
</section><div><a class="slider-prev" href="#арифметика-робинсона"></a><a class="slider-next" href="#схема-простого-доказательства-аналога-теоремы-гёделя-о-неполноте"></a></div>
<section id="схема-простого-доказательства-аналога-теоремы-гёделя-о-неполноте" class="slide level1">
<h1>Схема простого доказательства аналога теоремы Гёделя о неполноте</h1>
<p>Предположим, что существует полная и непротиворечивая <em>рекурсивно аксиоматизируемая</em> формальная система F, в которой представимы утверждения о машинах Тьюринга. Тогда с помощью этой системы проблема останова разрешима следующим образом.</p>
<p>Пусть дана машина M, про которую нужно определить, останавливается ли она на пустой ленте. Это не ограничивает общность: для любой машины с входными данными мы можем подставить эти входные данные в код машины.</p>
<p>Начнём перечисление всех выводов, допустимых в теории F. Для каждого из них проверяем, является ли он доказательством утверждения «M останавливается на пустой ленте» или доказательством утверждения «M не останавливается на пустой ленте».</p>
<p>Т.к. F полна, рано или мы найдём одно из доказательств. Т.к. F непротиворечива, оно будет корректным.</p>
<p>Таким образом, мы построили процедуру разрешения неразрешимой проблемы останова, следовательно, система F из нашего предположения не может существовать.</p>
</section><div><a class="slider-prev" href="#первая-теорема-гёделя-о-неполноте"></a><a class="slider-next" href="#доказательство-хайтина-с-использованием-колмогоровской-сложности"></a></div>
<section id="доказательство-хайтина-с-использованием-колмогоровской-сложности" class="slide level1">
<h1>Доказательство Хайтина с использованием Колмогоровской сложности</h1>
<p>Используется парадокс Берри: определение "наименьшее положительное число, которое нельзя определить восемью словами" определет такое число восемью словами (на русском языке).</p>
<h2 id="колмогоровская-сложность">Колмогоровская сложность</h2>
<p>Зафиксируем некоторый язык программирования (C, LISP, код универсальной машины Тьюринга и т.п.).</p>
<p>Колмогоровская сложность целого числа x (K(x)) — минимальная длина программы (в битах) на выбранном языке программирования, которая выводит x и останавливается.</p>
</section><div><a class="slider-prev" href="#схема-простого-доказательства-аналога-теоремы-гёделя-о-неполноте"></a><a class="slider-next" href="#доказательство-хайтина"></a></div>
<section id="доказательство-хайтина" class="slide level1">
<h1>Доказательство Хайтина</h1>
<p>Утверждение теоремы: для любой достаточно выразительной формальной теории существует такое число L (зависит от теории и языка программирования), такое, что для любого числа x утверждение K(x) &gt; L не может быть доказано в этой теории.</p>
<!--
Пусть заданы язык программирования и непротиворечивая формальная теория S, для которой мы можем:
- написать программу, перечисляющую все доказательства ℕ → proof
- написать программу, проверяющую, что доказательство доказывает некоторое утверждение
-->
<p>Пусть для любого L есть такое число z, что существует формальное доказательство "K(z) &gt; L". Пусть w — первое по лексикографическому порядку доказательство этого утверждения. Возможно написать программу P, которая перебором доказательств находит для данного L такое число z. Тогда длина программы — |P| = C + log<sub>2</sub> L. Тогда для достаточно большого L, |P| &lt; L. Тогда K(z) = |P| &lt; L.</p>
<p>Программ длины не более L битов — не более 2<sup>L+1</sup>, следовательно, существует хотя бы одно 0 ≤ x ≤ 2<sup>L+1</sup>, такое, что K(x) &gt; L.</p>
</section><div><a class="slider-prev" href="#доказательство-хайтина-с-использованием-колмогоровской-сложности"></a><a class="slider-next" href="#вторая-теорема-гёделя-о-неполноте"></a></div>
<section id="вторая-теорема-гёделя-о-неполноте" class="slide level1">
<h1>Вторая теорема Гёделя о неполноте</h1>
<p>Если в формальной системе можно представлять утверждения об арифметике и о формальной доказуемости, и если такая система включает формулу, представляющую непротиворечивость этой системы, то такая система противоречива.</p>
<p>(непротиворечивость формальной системы нельзя показать внутри самой этой системы)</p>
</section><div><a class="slider-prev" href="#доказательство-хайтина"></a><a class="slider-next" href="#схема-доказательства-второй-теоремы-гёделя-о-неполноте-с-помощью-колмогоровской-сложности"></a></div>
<section id="схема-доказательства-второй-теоремы-гёделя-о-неполноте-с-помощью-колмогоровской-сложности" class="slide level1">
<h1>Схема доказательства аналога второй теоремы Гёделя о неполноте с помощью Колмогоровской сложности</h1>
<p>Парадокс "неожиданной контрольной": преподаватель объявляет классу "на следующей неделе будет контрольная, но вы не можете узнать заранее, в какой день она будет".</p>
<p>Пусть L — число из предыдущего доказательства для заданной формальной системы. Пусть m — количество целых чисел 0 ≤ x ≤ 2<sup>L+1</sup>, таких, что K(x) &gt; L. m ≥ 1.</p>
<p>Пусть m = 1. Тогда существует единственное x: K(x) &gt; L, а все остальные числа в интервале имеют сложность &lt; L. Тогда можно построить формальное доказательство того, что K(x) &gt; L, путём перебора всех формальных доказательств K(y) ≤ L, пока не найдём 2<sup>L+1</sup> таких y; оставшееся — это x.</p>
<p>Существование формального доказательства противоречит определению L, поэтому если система F непротиворечива, m ≥ 2.</p>
</section><div><a class="slider-prev" href="#вторая-теорема-гёделя-о-неполноте"></a><a class="slider-next" href="#схема-доказательства-второй-теоремы-гёделя-о-неполноте"></a></div>
<section id="схема-доказательства-второй-теоремы-гёделя-о-неполноте" class="slide level1">
<h1>Схема доказательства аналога второй теоремы Гёделя о неполноте</h1>
<p>Если система F непротиворечива, m ≥ 2. В достаточно выразительной теории можно записать и доказать это необходимое условие.</p>
<p>Если в системе F можно доказать её непротиворечивость, в ней можно доказать и то, что m ≥ 2.</p>
<p>Далее — аналогичным образом поднимаем оценку снизу на значение m, пока не получим противоречие.</p>
</section><div><a class="slider-prev" href="#схема-доказательства-второй-теоремы-гёделя-о-неполноте-с-помощью-колмогоровской-сложности"></a><a class="slider-next" href="#теоремы-гёделя-о-неполноте"></a></div>
<section id="теоремы-гёделя-о-неполноте" class="slide level1">
<h1>Теоремы Гёделя о неполноте</h1>
<p>Схемы классических доказательств теорем Гёделя о неполноте. <a href="http://plato.stanford.edu/entries/goedel-incompleteness/" class="uri">http://plato.stanford.edu/entries/goedel-incompleteness/</a></p>
<p>Доказательства с помощью сведения к проблеме останова, использованные в презентации: <a href="http://www.scottaaronson.com/blog/?p=710" class="uri">http://www.scottaaronson.com/blog/?p=710</a></p>
<p>Доказательство первой теоремы Гёделя с использованием понятий функционального программирования (А.М. Миронов, МаТИС): <a href="http://intsysjournal.org/articles/is04/17_mironov.pdf" class="uri">http://intsysjournal.org/articles/is04/17_mironov.pdf</a></p>
</section><div><a class="slider-prev" href="#схема-доказательства-второй-теоремы-гёделя-о-неполноте"></a><a class="slider-next" href="#программа-гильберта-1"></a></div>
<section id="программа-гильберта-1" class="slide level1">
<h1>Программа Гильберта</h1>
<p>Искомые свойства математики:</p>
<ol type="1">
<li class="fragment"><del>Полнота (мы можем переписыванием получить из аксиом все истинные утверждения математики)</del></li>
<li class="fragment"><del>Непротиворечивость (мы не можем получить переписыванием из аксиом ложное утверждение)</del></li>
<li class="fragment"><del>Разрешимость (руководствуясь простым набором правил можно для любой формулы получить, выводима она или нет).</del></li>
</ol>
<h2 id="но-не-всё-потеряно">Но не всё потеряно</h2>
</section><div><a class="slider-prev" href="#теоремы-гёделя-о-неполноте"></a><a class="slider-next" href="#теория-моделей-и-теория-доказательств"></a></div>
<section id="теория-моделей-и-теория-доказательств" class="slide level1">
<h1>Теория моделей и теория доказательств</h1>
<p>Теория моделей — изучает связь синтаксиса (формальных систем) и семантики (моделей для таких систем)</p>
<p>Теоретико-модельные подходы к формальной верификации: программа представляется в виде некоторой модели, допускающей исчерпывающую проверку интересующих свойств (enumerative and symbolic model checking). Обычно — автоматные модели, а также методы абстрактной интерпретации (символьные вычисления и т.п.).</p>
<p>Теория доказательств — изучает структуру формальных доказательств</p>
<p>Дедуктивные (теоретико-доказательные) подходы к формальной верификации — программа и свойства записываются в виде формул в формальной системе, доказательства строятся как вывод в формальной системе.</p>
<!-- Next time

# Логика второго порядка
— допускается квантификация по отношениям. 
# Естественная дедукция

# Системы переписывания термов и правила редукции

# Конфлюэнтность

# Теорема Чёрча-Россера

# Параллельные редукции

# Свойство нормализации

# Свойство сильной нормализации

# Вычисления за пределами тезиса Чёрча-Тьюринга
-->
</section><div><a class="slider-prev" href="#программа-гильберта-1"></a><a class="slider-next" href="#задачи"></a></div>
<section id="задачи" class="slide level1">
<h1>Задачи</h1>
<dl>
<dt class="fragment"><strong>Задача 4.1. ***</strong></dt>
<dd class="fragment">Сформулировать проблему останова в виде формулы логики первого порядка над арифметикой Робинсона.
</dd>
<dt class="fragment"><strong>Задача 4.2. (5* / корень из числа соавторов)</strong></dt>
<dd class="fragment">По следующей ссылке приведено средство для разработки визуализаторов логического вывода: <a href="http://www.is.ocha.ac.jp/~asai/MikiBeta/" class="uri">http://www.is.ocha.ac.jp/~asai/MikiBeta/</a> Необходимо повторить этот результат — разработать средство для достаточно простого создания визуализаторов логического вывода как минимум систем первого порядка на HTML5/CSS/JavaScript (желательно — опубликовать в OpenSource, как пример эмулятора машины Тьюринга с предыдущего занятия).
</dd>
<dt class="fragment"><strong>Задача 4.3 (5*)</strong></dt>
<dd class="fragment">Закодировать проверку нетривиального математического утверждения машиной Тьюринга с использованием методов, представленных в <a href="http://www.scottaaronson.com/blog/?p=2725" class="uri">http://www.scottaaronson.com/blog/?p=2725</a>
</dd>
</dl>
</section><div><a class="slider-prev" href="#теория-моделей-и-теория-доказательств"></a><a class="slider-next"></a></div>

<!-- start page -->
   <div id="slider">
       <a href="#математические-модели-вычислений" class="slider-start">PLAY</a>
   </div>

   <!-- progressbar container -->
   <div class="slider-progress"></div>
   </article>
  </div>

  
  <script type="text/javascript">
  document.addEventListener("keydown", function(e) {
     if (e.altKey || e.ctrlKey || e.metaKey || e.shiftKey) { return; }
     switch (e.keyCode) {
       case 35: // End
          var arr = document.querySelectorAll("a.slider-next:link");
          var a = arr[arr.length - 1];
          if (a && a.href) {
            window.location = a.href;
          }
          break;
       case 36: // Home
          var a = document.querySelector("a.slider-start");
          if (a && a.href) {
            window.location = a.href;
          }
          break;
       case 37: // left arrow
         var a = document.querySelector("section:target ~ div a.slider-prev");
         if (a && a.href) {
           window.location = a.href;
         }
         break;
       case 39: // right arrow
         var a = document.querySelector("section:target ~ div a.slider-next");
         if (a && a.href) {
           window.location = a.href;
         }
         break;
     }
  });
  </script>
  

</body></html>
